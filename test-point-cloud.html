<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Point Cloud Performance Test</title>
  <style>
    :root {
      /* Colors */
      --color-bg-primary: #0a0a1a;
      --color-bg-panel: rgba(10, 10, 26, 0.95);
      --color-bg-button: rgba(26, 26, 46, 0.7);
      --color-border: #1a1a2e;
      --color-border-light: #333;
      --color-text-primary: #ffffff;
      --color-text-secondary: #999999;
      --color-accent: #a78bfa;
      --color-accent-hover: #c4b5fd;
      --color-danger: #ff4444;

      /* Typography */
      --font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      --font-size-xs: 12px;
      --font-size-sm: 13px;
      --font-size-base: 14px;
      --font-size-lg: 16px;
      --font-size-xl: 18px;
      --font-weight-normal: 400;
      --font-weight-medium: 500;
      --font-weight-bold: 700;

      /* Spacing */
      --spacing-xs: 8px;
      --spacing-sm: 12px;
      --spacing-md: 16px;
      --spacing-lg: 20px;
      --spacing-xl: 24px;

      /* Border & Shadow */
      --border-radius-sm: 8px;
      --border-radius-md: 12px;
      --border-radius-lg: 16px;
      --shadow-panel: 0 8px 32px rgba(0, 0, 0, 0.6);
      --shadow-button: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: var(--color-bg-primary);
      color: var(--color-text-primary);
      font-family: var(--font-family);
      font-size: var(--font-size-base);
      line-height: 1.5;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      touch-action: manipulation;
    }
    canvas {
      display: block;
    }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      color: #fff;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
      max-width: 200px;
    }
    button {
      margin: 5px 0;
      padding: 8px 16px;
      min-height: 44px;
      background: #333;
      color: #fff;
      border: 1px solid #666;
      border-radius: 3px;
      cursor: pointer;
      width: 100%;
      font-size: 13px;
      -webkit-tap-highlight-color: transparent;
    }
    button:hover {
      background: #444;
    }
    button.active {
      background: #0a0;
      color: #000;
    }
    #search {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      width: min(520px, 92vw);
    }
    /* Floating username label anchored to selected star */
    #star-label {
      position: fixed;
      pointer-events: none;
      display: none;
      z-index: 50;
      transform: translate(-50%, calc(-100% - 22px));
      white-space: nowrap;
      text-align: center;
    }
    #star-label .star-label-name {
      display: inline-block;
      background: rgba(8, 8, 22, 0.82);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 20px;
      padding: 3px 12px 3px 8px;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
      letter-spacing: 0.02em;
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #star-label .star-label-pip {
      width: 6px; height: 6px;
      border-radius: 50%;
      background: #fff;
      flex-shrink: 0;
      opacity: 0.7;
    }

    #clear-connections-btn {
      position: absolute;
      top: 72px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      background: rgba(0, 204, 255, 0.15);
      border: 1px solid rgba(0, 204, 255, 0.4);
      border-radius: 20px;
      color: #00ccff;
      font-family: var(--font-family);
      font-size: var(--font-size-sm);
      padding: 6px 16px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
      backdrop-filter: blur(4px);
      white-space: nowrap;
    }
    #clear-connections-btn:hover {
      background: rgba(0, 204, 255, 0.3);
      color: #ffffff;
    }
    #search input {
      width: 100%;
      padding: 16px 24px;
      background: var(--color-bg-button);
      border: 1px solid var(--color-border-light);
      border-radius: 28px;
      color: var(--color-text-primary);
      font-family: var(--font-family);
      font-size: 16px;
      outline: none;
      transition: all 0.2s ease;
      box-sizing: border-box;
    }
    #search input:focus {
      border-color: var(--color-accent);
      background: rgba(26, 26, 46, 0.9);
      box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.18);
    }
    #search input::placeholder {
      color: var(--color-text-secondary);
    }
    /* Search Autocomplete Dropdown */
    #search-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: 8px;
      background: var(--color-bg-panel);
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-md);
      max-height: 400px;
      overflow-y: auto;
      display: none;
      z-index: 101;
      box-shadow: var(--shadow-panel);
      backdrop-filter: blur(12px);
    }
    #search-dropdown.visible {
      display: block;
    }
    .search-result-item {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      cursor: pointer;
      transition: background 0.2s ease;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    .search-result-item:last-child {
      border-bottom: none;
    }
    .search-result-item:hover {
      background: rgba(0, 204, 102, 0.1);
    }
    .search-result-item.selected {
      background: rgba(0, 204, 102, 0.15);
    }
    .search-result-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--color-accent);
      color: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: var(--font-weight-bold);
      font-size: 14px;
      margin-right: 12px;
      flex-shrink: 0;
      border: 2px solid rgba(0, 204, 102, 0.3);
      position: relative;
      overflow: hidden;
    }
    .search-result-avatar img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      object-fit: cover;
      object-position: center;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }
    .search-result-avatar img.loaded {
      opacity: 1;
    }
    .search-result-avatar.loading {
      background: linear-gradient(
        90deg,
        var(--color-accent) 0%,
        rgba(0, 204, 102, 0.6) 50%,
        var(--color-accent) 100%
      );
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }
    .search-result-info {
      flex: 1;
      min-width: 0;
    }
    .search-result-username {
      font-weight: var(--font-weight-medium);
      color: var(--color-text-primary);
      font-size: var(--font-size-base);
      margin-bottom: 2px;
    }
    .search-result-meta {
      font-size: var(--font-size-xs);
      color: var(--color-text-secondary);
    }
    .search-result-highlight {
      background: rgba(0, 204, 102, 0.3);
      font-weight: var(--font-weight-bold);
    }
    #detail {
      position: fixed;
      top: 0;
      right: -500px; /* Hidden off-screen (width + padding + shadow) */
      width: 400px;
      height: 100vh;
      background: var(--color-bg-panel);
      border-left: 2px solid var(--color-accent);
      border-top-left-radius: var(--border-radius-lg);
      border-bottom-left-radius: var(--border-radius-lg);
      color: var(--color-text-primary);
      z-index: 150;
      padding: 30px;
      overflow-y: auto;
      transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  filter 0.18s ease,
                  opacity 0.18s ease;
      box-shadow: var(--shadow-panel);
    }
    #detail.visible {
      right: 0;
    }
    #detail.content-transitioning {
      filter: blur(6px);
      opacity: 0.35;
      pointer-events: none;
    }
    .detail-drag-handle {
      display: none; /* shown only in mobile media query */
    }
    #detail .close {
      position: absolute;
      top: 15px;
      right: 20px;
      cursor: pointer;
      color: var(--color-text-secondary);
      font-size: 30px;
      transition: color 0.2s ease;
    }
    #detail .close:hover {
      color: var(--color-accent);
    }
    #detail h3 {
      margin: 0 0 20px 0;
      color: var(--color-accent);
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
    }
    #detail p {
      margin: 8px 0;
      font-size: var(--font-size-sm);
      line-height: 1.6;
    }
    #detail strong {
      color: var(--color-text-secondary);
      font-weight: var(--font-weight-medium);
    }
    /* Profile Picture in Detail Panel */
    .detail-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .detail-header-info {
      text-align: center;
      width: 100%;
    }
    .detail-header-info h3 {
      margin: 0 0 8px 0;
      text-align: center;
    }
    .detail-avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: var(--color-accent);
      color: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: var(--font-weight-bold);
      font-size: 48px;
      margin: 0 auto 16px;
      flex-shrink: 0;
      border: 4px solid rgba(0, 204, 102, 0.3);
      position: relative;
      overflow: hidden;
    }
    .detail-avatar img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      object-fit: cover;
      object-position: center;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }
    .detail-avatar img.loaded {
      opacity: 1;
    }
    .detail-avatar.loading {
      background: linear-gradient(
        90deg,
        var(--color-accent) 0%,
        rgba(0, 204, 102, 0.6) 50%,
        var(--color-accent) 100%
      );
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }
    .detail-header-info h3 {
      margin: 0 0 4px 0;
    }
    .detail-header-id {
      font-size: var(--font-size-sm);
      color: var(--color-text-secondary);
    }
    #detail .risk-low { color: #4af; }
    #detail .risk-medium { color: #fa0; }
    #detail .risk-high { color: #f44; }

    /* Instagram-style post grid */
    /* Supporter playing cards ‚Äî portrait shape, stacked deck */
    .supporter-card {
      position: absolute;
      top: 0;
      left: 50%;
      width: 100px;
      height: 140px;
      border-radius: 10px;
      overflow: hidden;
      cursor: pointer;
      border: 1.5px solid rgba(167,139,250,0.35);
      box-shadow: 0 4px 18px rgba(0,0,0,0.55);
      transform-origin: bottom center;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .supporter-card:hover {
      box-shadow: 0 8px 28px rgba(167,139,250,0.45);
      border-color: rgba(167,139,250,0.7);
    }
    .supporter-card-bg {
      position: absolute; inset: 0;
      background: linear-gradient(160deg, rgba(30,20,60,0.9), rgba(10,8,30,0.97));
      overflow: hidden;
    }
    .supporter-card-bg img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      opacity: 0.75;
    }
    .supporter-card-initials {
      position: absolute; inset: 0;
      display: flex; align-items: center; justify-content: center;
      font-size: 32px; font-weight: 700; color: rgba(167,139,250,0.6);
      letter-spacing: -0.02em;
    }
    .supporter-card-overlay {
      position: absolute; inset: 0;
      background: linear-gradient(to top, rgba(8,6,24,0.92) 0%, rgba(8,6,24,0.2) 55%, transparent 100%);
    }
    .supporter-card-label {
      position: absolute;
      bottom: 0; left: 0; right: 0;
      padding: 8px 7px 7px;
      display: flex; flex-direction: column; gap: 1px;
    }
    .supporter-card-name {
      font-size: 11px; font-weight: 700; color: #fff;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      text-shadow: 0 1px 4px rgba(0,0,0,0.9);
      letter-spacing: 0.01em;
    }
    .supporter-card-count {
      font-size: 10px; color: var(--color-accent);
      font-weight: 500;
    }

    .posts-section {
      margin-top: 24px;
      padding-top: 20px;
      border-top: 1px solid var(--color-border);
    }
    .posts-section h4 {
      margin: 0 0 16px 0;
      color: var(--color-text-primary);
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-medium);
    }
    .posts-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
      margin-bottom: 16px;
    }
    .post-item {
      aspect-ratio: 1;
      background: var(--color-border);
      border-radius: 4px;
      overflow: hidden;
      cursor: pointer;
      position: relative;
      transition: transform 0.2s ease;
    }
    .post-item:hover {
      transform: scale(1.05);
      z-index: 1;
    }
    .post-item img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }
    .post-item img.loaded {
      opacity: 1;
    }
    .post-item.loading {
      background: linear-gradient(
        90deg,
        var(--color-border) 0%,
        rgba(26, 26, 46, 0.6) 50%,
        var(--color-border) 100%
      );
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }
    .post-item .post-text {
      position: absolute;
      inset: 0;
      padding: 8px;
      font-size: 11px;
      line-height: 1.3;
      color: var(--color-text-primary);
      background: rgba(10, 10, 26, 0.85);
      backdrop-filter: blur(4px);
      display: -webkit-box;
      -webkit-line-clamp: 6;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .posts-loading {
      text-align: center;
      padding: 20px;
      color: var(--color-text-secondary);
      font-size: var(--font-size-sm);
    }

    /* Expanded Post View */
    #post-expanded {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--color-bg-panel);
      z-index: 10;
      overflow-y: auto;
      transform: translateY(100%);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: none;
    }
    #post-expanded.visible {
      transform: translateY(0);
      display: block;
    }
    .post-expanded-back {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 20;
      background: rgba(10, 10, 26, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 50%;
      color: var(--color-text-primary);
      font-size: 20px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
      backdrop-filter: blur(4px);
      line-height: 1;
    }
    .post-expanded-back:hover {
      background: rgba(0, 204, 102, 0.2);
      color: var(--color-accent);
    }
    .post-expanded-content {
      padding: 0;
    }
    .post-expanded-image {
      width: 100%;
      max-height: 400px;
      object-fit: cover;
      object-position: center;
      display: block;
    }
    .post-expanded-text {
      padding: 20px;
      font-size: var(--font-size-base);
      line-height: 1.6;
      color: var(--color-text-primary);
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .post-expanded-meta {
      padding: 0 20px 20px 20px;
      font-size: var(--font-size-sm);
      color: var(--color-text-secondary);
      border-bottom: 1px solid var(--color-border);
    }
    .post-comments-section {
      padding: 20px;
    }
    .post-comments-header {
      font-size: var(--font-size-lg);
      font-weight: var(--font-weight-bold);
      color: var(--color-text-primary);
      margin: 0 0 16px 0;
    }
    .comment-item {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--color-border);
    }
    .comment-item:last-child {
      border-bottom: none;
    }
    .comment-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--color-accent);
      color: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: var(--font-weight-bold);
      font-size: 16px;
      flex-shrink: 0;
      overflow: hidden;
      position: relative;
    }
    .comment-avatar img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
    }
    .comment-content {
      flex: 1;
      min-width: 0;
    }
    .comment-header {
      display: flex;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 4px;
    }
    .comment-username {
      font-weight: var(--font-weight-medium);
      color: var(--color-text-primary);
      font-size: var(--font-size-base);
    }
    .comment-date {
      font-size: var(--font-size-xs);
      color: var(--color-text-secondary);
    }
    .comment-text {
      font-size: var(--font-size-sm);
      line-height: 1.5;
      color: var(--color-text-primary);
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .comments-loading {
      text-align: center;
      padding: 20px;
      color: var(--color-text-secondary);
      font-size: var(--font-size-sm);
    }
    #help {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--color-bg-panel);
      border: 2px solid var(--color-accent);
      border-radius: var(--border-radius-lg);
      padding: 30px;
      color: var(--color-text-primary);
      z-index: 200;
      display: none;
      max-width: 600px;
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow-panel);
    }
    #help.visible {
      display: block;
    }
    #help h2 {
      margin: 0 0 20px 0;
      color: var(--color-accent);
      font-weight: var(--font-weight-bold);
      font-size: var(--font-size-xl);
      text-align: center;
    }
    #help .shortcuts {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 10px;
      margin: 20px 0;
    }
    #help .key {
      background: #333;
      padding: 5px 10px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 12px;
      text-align: center;
      border: 1px solid #666;
    }
    #help .desc {
      padding: 5px 0;
      font-size: 13px;
    }
    #help button {
      width: 100%;
      margin-top: 20px;
      padding: 12px;
      font-size: 14px;
    }
    /* Button System */
    button, .btn {
      padding: 10px 20px;
      border: 1px solid var(--color-border-light);
      border-radius: var(--border-radius-sm);
      background: var(--color-bg-button);
      color: var(--color-text-primary);
      font-family: var(--font-family);
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-medium);
      cursor: pointer;
      transition: all 0.2s ease;
      outline: none;
    }
    button:hover, .btn:hover {
      background: rgba(26, 26, 46, 0.9);
      border-color: var(--color-accent);
      transform: translateY(-1px);
      box-shadow: var(--shadow-button);
    }
    button:active, .btn:active {
      transform: translateY(0);
    }
    .btn-primary {
      background: var(--color-accent);
      border-color: var(--color-accent);
      color: #000;
      font-weight: var(--font-weight-medium);
    }
    .btn-primary:hover {
      background: var(--color-accent-hover);
      border-color: var(--color-accent-hover);
    }
    .btn-danger {
      background: var(--color-danger);
      border-color: var(--color-danger);
      color: #fff;
    }
    .btn-danger:hover {
      background: #ff6666;
      border-color: #ff6666;
    }
    .btn-block {
      width: 100%;
      display: block;
    }
    #help-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--color-bg-button);
      border: 1px solid var(--color-accent);
      color: var(--color-accent);
      font-size: 20px;
      cursor: pointer;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    #help-btn:hover {
      background: rgba(26, 26, 46, 0.9);
      border-color: var(--color-accent-hover);
      color: var(--color-accent-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-button);
    }
    /* Bottom controls suggestions ‚Äî hides after first use */
    #controls-suggestions {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 90;
      padding: 10px 20px;
      background: var(--color-bg-panel);
      border: 1px solid var(--color-border-light);
      border-radius: 24px;
      color: var(--color-text-secondary);
      font-size: var(--font-size-sm);
      white-space: nowrap;
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow-panel);
      transition: opacity 0.35s ease, transform 0.35s ease;
      pointer-events: none;
    }
    #controls-suggestions.hidden {
      opacity: 0;
      transform: translateX(-50%) translateY(12px);
      pointer-events: none;
    }
    #admin-sidebar {
      position: fixed;
      top: 0;
      left: -400px; /* Hidden off-screen (width + shadow) */
      width: 350px;
      height: 100vh;
      background: var(--color-bg-panel);
      border-right: 2px solid var(--color-accent);
      border-top-right-radius: var(--border-radius-lg);
      border-bottom-right-radius: var(--border-radius-lg);
      color: var(--color-text-primary);
      z-index: 150;
      padding: var(--spacing-lg);
      overflow-y: auto;
      transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-panel);
    }
    #admin-sidebar.visible {
      left: 0;
    }
    /* Close button inside sidebar */
    #admin-sidebar .close {
      position: absolute;
      top: var(--spacing-lg);
      right: var(--spacing-lg);
      font-size: 24px;
      color: var(--color-text-secondary);
      cursor: pointer;
      background: none;
      border: none;
      padding: var(--spacing-xs);
      transition: color 0.2s ease;
      z-index: 1;
    }
    #admin-sidebar .close:hover {
      color: var(--color-accent);
    }
    #admin-sidebar h2, #admin-sidebar h3 {
      color: var(--color-accent);
      font-weight: var(--font-weight-bold);
    }
    #admin-toggle {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #0a0;
      color: #0a0;
      font-size: 20px;
      cursor: pointer;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #admin-toggle:hover {
      background: rgba(0, 10, 0, 0.9);
    }
    .job-item {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #333;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0;
    }
    .progress-bar {
      width: 100%;
      height: 20px;
      background: #222;
      border-radius: 10px;
      overflow: hidden;
      margin: 5px 0;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #0a0, #0f0);
      transition: width 0.3s ease;
    }
    .job-status {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 11px;
      margin-left: 5px;
    }
    .job-status.running { background: #0a0; color: #000; }
    .job-status.completed { background: #666; color: #fff; }
    .job-status.error { background: #a00; color: #fff; }

    /* ‚Äî‚Äî‚Äî Mobile & small screens ‚Äî‚Äî‚Äî */
    @media (max-width: 768px) {
      #controls {
        top: auto;
        right: 10px;
        bottom: calc(20px + env(safe-area-inset-bottom, 0px));
        left: 10px;
        max-width: none;
        width: auto;
        max-height: 42vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding: 12px;
        border-radius: var(--border-radius-md);
      }
      #search {
        top: calc(12px + env(safe-area-inset-top, 0px));
        left: 12px;
        right: 12px;
        width: auto;
        max-width: none;
        transform: none;
      }
      #search input {
        padding: 14px 20px;
        font-size: 16px; /* prevents iOS zoom on focus */
      }
      #clear-connections-btn {
        top: auto;
        bottom: calc(42vh + 28px + env(safe-area-inset-bottom, 0px));
        left: 12px;
        right: 12px;
        transform: none;
        width: auto;
        padding: 10px 16px;
        font-size: var(--font-size-sm);
      }
      /* Mobile: detail as bottom sheet ‚Äî 1/3 screen by default, scroll up for full */
      #detail {
        top: auto;
        right: 0;
        left: 0;
        bottom: 0;
        width: 100%;
        max-width: 100vw;
        height: 33.33vh;
        max-height: 33.33vh;
        border-left: none;
        border-top: 2px solid var(--color-accent);
        border-top-left-radius: var(--border-radius-lg);
        border-top-right-radius: var(--border-radius-lg);
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        padding: 12px 20px 20px;
        padding-top: 8px;
        padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px));
        padding-left: calc(20px + env(safe-area-inset-left, 0px));
        padding-right: calc(20px + env(safe-area-inset-right, 0px));
        transform: translateY(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    height 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        touch-action: pan-y;
      }
      #detail.visible {
        transform: translateY(0);
      }
      /* Expanded: full height so user can scroll content; scroll down to collapse */
      #detail.visible.detail-expanded {
        height: 92vh;
        max-height: 92vh;
      }
      /* Drag handle ‚Äî visible only on mobile (same breakpoint as #detail bottom sheet) */
      .detail-drag-handle {
        display: block;
        width: 40px;
        height: 4px;
        margin: 0 auto 12px;
        background: rgba(255, 255, 255, 0.35);
        border-radius: 2px;
        flex-shrink: 0;
        cursor: grab;
        touch-action: none;
      }
      .detail-drag-handle:active {
        cursor: grabbing;
      }
      #admin-sidebar {
        width: 100%;
        left: -100%;
        max-width: 100vw;
        padding: 20px;
        padding-top: calc(20px + env(safe-area-inset-top, 0px));
        padding-left: calc(20px + env(safe-area-inset-left, 0px));
        padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px));
      }
      #admin-sidebar.visible {
        left: 0;
      }
      #help {
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        max-width: none;
        width: 100%;
        height: 100%;
        transform: none;
        border-radius: 0;
        padding: 24px;
        padding-top: calc(24px + env(safe-area-inset-top, 0px));
        padding-bottom: calc(24px + env(safe-area-inset-bottom, 0px));
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      #help .shortcuts {
        gap: 12px 16px;
      }
      #help .key, #help .desc {
        padding: 8px 0;
        min-height: 44px;
        display: flex;
        align-items: center;
      }
      #help .key {
        padding: 8px 12px;
      }
      #help-btn {
        bottom: calc(20px + env(safe-area-inset-bottom, 0px));
        right: calc(20px + env(safe-area-inset-right, 0px));
        width: 48px;
        height: 48px;
        font-size: 22px;
      }
      #admin-toggle {
        top: calc(12px + env(safe-area-inset-top, 0px));
        left: calc(12px + env(safe-area-inset-left, 0px));
        width: 48px;
        height: 48px;
        font-size: 22px;
      }
      #controls-suggestions {
        left: 12px;
        right: 12px;
        bottom: calc(42vh + 16px + env(safe-area-inset-bottom, 0px));
        transform: none;
        width: auto;
        max-width: none;
        white-space: normal;
        text-align: center;
        padding: 12px 16px;
        font-size: var(--font-size-xs);
      }
      #controls-suggestions.hidden {
        transform: translateY(12px);
      }
      .detail-avatar {
        width: 96px;
        height: 96px;
        font-size: 36px;
      }
      .posts-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
      }
      .post-expanded-back {
        top: calc(12px + env(safe-area-inset-top, 0px));
        left: calc(12px + env(safe-area-inset-left, 0px));
        width: 44px;
        height: 44px;
        font-size: 22px;
      }
      .post-expanded-image {
        max-height: 50vh;
      }
      .search-result-item {
        padding: 14px 16px;
        min-height: 48px;
      }
      .supporter-card {
        width: 90px;
        height: 126px;
      }
    }

    @media (max-width: 480px) {
      #controls {
        bottom: calc(16px + env(safe-area-inset-bottom, 0px));
        left: 8px;
        right: 8px;
        max-height: 38vh;
        padding: 10px;
      }
      #controls-suggestions {
        bottom: calc(38vh + 12px + env(safe-area-inset-bottom, 0px));
      }
      #clear-connections-btn {
        bottom: calc(38vh + 24px + env(safe-area-inset-bottom, 0px));
        left: 8px;
        right: 8px;
      }
      #detail h3 {
        font-size: var(--font-size-lg);
      }
      #detail p, #detail .detail-header-id {
        font-size: var(--font-size-sm);
      }
      .posts-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 4px;
      }
      .post-item .post-text {
        font-size: 10px;
        -webkit-line-clamp: 4;
      }
    }
  </style>
</head>
<body>
  <div id="controls">
    <button onclick="generatePoints(10000)">10K Points</button>
    <button onclick="generatePoints(50000)">50K Points</button>
    <button onclick="generatePoints(100000)" class="active">100K Points</button>
    <button onclick="generatePoints(250000)">250K Points</button>
    <button onclick="generatePoints(500000)">500K Points</button>
    <button onclick="generatePoints(1000000)">1M Points</button>
    <div style="margin: 10px 0; padding: 10px 0; border-top: 1px solid #666;">
      <strong>Navigation</strong>
    </div>
    <button onclick="toggleRotation()">Toggle Auto-Rotate</button>
    <button onclick="resetCamera()">Reset Camera</button>
    <button onclick="focusOnCluster()">Focus Random Cluster</button>
    <div style="margin-top: 10px; font-size: 11px; color: #888; line-height: 1.4;">
      üí° Drag to rotate<br>
      üîç Scroll to zoom<br>
      üëÜ Click points for info
    </div>
  </div>

  <button id="admin-toggle" onclick="toggleAdmin()" title="Admin Dashboard (A)">‚ò∞</button>

  <div id="search">
    <input type="text" placeholder="Search by username..." onkeyup="searchMember(event)" onfocus="showSearchDropdown()" />
    <div id="search-dropdown">
      <!-- Search results will be populated here -->
    </div>
  </div>

  <button id="clear-connections-btn" onclick="clearConnectionLines()" title="Clear all connection lines" style="display: none;">‚úï Clear connections</button>

  <!-- Floating username label, positioned via JS each frame -->
  <div id="star-label">
    <div class="star-label-name">
      <span class="star-label-pip" id="star-label-pip"></span>
      <span id="star-label-text"></span>
    </div>
  </div>

  <div id="detail">
    <div id="detail-drag-handle" class="detail-drag-handle" aria-hidden="true"></div>
    <span class="close" onclick="closeDetail()">‚úï</span>
    <div class="detail-header">
      <div class="detail-avatar" id="detail-avatar">
        <!-- Profile picture or initials will be here -->
      </div>
      <div class="detail-header-info">
        <h3 id="detail-username">-</h3>
        <div class="detail-header-id"><strong>ID:</strong> <span id="detail-id">-</span></div>
      </div>
    </div>
    <div style="padding: 20px; background: rgba(255,255,255,0.05); border-radius: 8px;">
      <p><strong>Username:</strong> <span id="detail-username-full">-</span></p>
      <p><strong>Position:</strong> <span id="detail-pos">-</span></p>
      <p><strong>Risk Level:</strong> <span id="detail-risk">-</span></p>

      <div id="risk-explanation" style="display: none; margin: 16px 0; padding: 16px; background: rgba(237, 73, 86, 0.1); border-left: 3px solid #ed4956; border-radius: 8px;">
        <h4 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #ed4956;">
          Why is this user at high risk?
        </h4>
        <p id="risk-explanation-text" style="margin: 0; font-size: 13px; line-height: 1.5; color: var(--color-text-primary);">
          <!-- Explanation will be inserted here -->
        </p>
      </div>

      <p><strong>Activity:</strong> <span id="detail-activity">-</span></p>
      <p><strong>Cluster:</strong> <span id="detail-cluster">-</span></p>
      <p><strong>Sobriety:</strong> <span id="detail-sobriety">-</span></p>
    </div>
    <button class="btn btn-primary btn-block" onclick="focusOnSelected()" style="margin-top: 10px;">Zoom to Member</button>

    <!-- Top 3 supported users ‚Äî portrait playing card deck -->
    <div id="supporters-section" style="display:none; margin: 20px 0 0 0;">
      <h4 style="margin: 0 0 16px 0; font-size: 12px; font-weight: 600; color: var(--color-text-secondary); text-transform: uppercase; letter-spacing: 0.08em;">Top Supported</h4>
      <div id="supporter-cards-container" style="position:relative; height: 160px;"></div>
    </div>

    <div class="posts-section">
      <h4>Posts</h4>
      <div id="posts-grid" class="posts-grid">
        <div class="posts-loading">Loading posts...</div>
      </div>
    </div>

    <!-- Expanded Post View -->
    <div id="post-expanded">
      <button class="post-expanded-back" onclick="closeExpandedPost()">‚Üê</button>
      <div class="post-expanded-content">
        <img id="post-expanded-image" class="post-expanded-image" crossorigin="anonymous" style="display: none;" />
        <div id="post-expanded-text" class="post-expanded-text"></div>
        <div id="post-expanded-meta" class="post-expanded-meta"></div>
      </div>
      <div class="post-comments-section">
        <h4 class="post-comments-header">Comments <span id="comment-count"></span></h4>
        <div id="post-comments-list">
          <div class="comments-loading">Loading comments...</div>
        </div>
      </div>
    </div>
  </div>

  <div id="admin-sidebar">
    <span class="close" onclick="toggleAdmin()">‚úï</span>
    <h2 style="margin-top: 0;">Admin Dashboard</h2>
    <div style="border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 20px;">
      <p style="margin: 5px 0;"><strong>Total Members:</strong> <span id="admin-total">0</span></p>
      <p style="margin: 5px 0;"><strong>Real Data Loaded:</strong> <span id="admin-real">0</span></p>
      <p style="margin: 5px 0;"><strong>Synthetic Data:</strong> <span id="admin-synthetic">100,000</span></p>
    </div>

    <h3 style="margin-top: 20px;">Performance</h3>
    <div style="border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 20px;">
      <p style="margin: 5px 0;"><strong>FPS:</strong> <span id="fps">0</span></p>
      <p style="margin: 5px 0;"><strong>Points:</strong> <span id="count">0</span></p>
      <p style="margin: 5px 0;"><strong>Memory:</strong> <span id="memory">0 MB</span></p>
      <p style="margin: 5px 0;"><strong>Draw Calls:</strong> <span id="draws">0</span></p>
      <p style="margin: 5px 0;"><strong>Geometry:</strong> <span id="geom">0 MB</span></p>
    </div>

    <h3 style="margin-top: 20px;">Background Jobs</h3>
    <div id="jobs-container">
      <!-- Jobs will be added here dynamically -->
    </div>

    <button class="btn btn-primary btn-block" onclick="startLoadRealDataJob()" style="margin-top: 20px;">Continue Loading Data</button>
    <button class="btn btn-danger btn-block" onclick="resetJobState()" style="margin-top: 10px;">Reset Job State</button>
    <button class="btn btn-block" onclick="clearSnapshot()" style="margin-top: 10px;">Clear Snapshot Cache</button>
    <button class="btn btn-block" onclick="clearAllJobs()" style="margin-top: 10px;">Clear Job History</button>
    <p id="snapshot-status" style="font-size: 11px; color: #888; margin-top: 8px; text-align: center;"></p>
  </div>

  <div id="help">
    <h2>Manifest Point Cloud ‚Äî Controls</h2>

    <div class="shortcuts">
      <div class="key">Drag</div>
      <div class="desc">Rotate camera around universe</div>

      <div class="key">Scroll</div>
      <div class="desc">Zoom in/out</div>

      <div class="key">Click</div>
      <div class="desc">Select member (show details)</div>

      <div class="key">R</div>
      <div class="desc">Toggle auto-rotation</div>

      <div class="key">H</div>
      <div class="desc">Reset camera to home position</div>

      <div class="key">F</div>
      <div class="desc">Focus on random cluster</div>

      <div class="key">A</div>
      <div class="desc">Toggle admin dashboard</div>

      <div class="key">/</div>
      <div class="desc">Focus search box</div>

      <div class="key">ESC</div>
      <div class="desc">Close panels</div>

      <div class="key">?</div>
      <div class="desc">Toggle this help screen</div>
    </div>

    <button onclick="toggleHelp()">Got it!</button>
  </div>

  <div id="controls-suggestions">Drag to rotate ¬∑ Scroll to zoom ¬∑ Click points for details</div>

  <button id="help-btn" onclick="toggleHelp()" title="Keyboard shortcuts (?)">?</button>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, points, controls;
    let rotating = false; // Start paused for better UX
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 0;
    let mouse = new THREE.Vector2();
    let raycaster = new THREE.Raycaster();
    // Drag detection ‚Äî suppress click when mouse moved > DRAG_THRESHOLD px
    let _mouseDownX = 0, _mouseDownY = 0, _isDrag = false;
    const DRAG_THRESHOLD = 5; // pixels
    let hoveredPoint = null;

    // Search optimization: debouncing and caching
    let searchTimeout = null;
    const searchCache = new Map(); // Cache key: query string, value: {results, timestamp, version}
    const SEARCH_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
    const SEARCH_CACHE_VERSION = 2; // Bump to invalidate old cache (e.g. stale profile picture data)
    const SEARCH_DEBOUNCE_DELAY = 300; // 300ms debounce

    // Debounce utility function
    function debounce(func, delay) {
      return function(...args) {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => func.apply(this, args), delay);
      };
    }

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a1a);
      scene.fog = new THREE.Fog(0x0a0a1a, 50, 200);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(120, 0, 80);
      camera.lookAt(0, 0, 0);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // OrbitControls for smooth navigation
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 0.1;  // Allow EXTREME close zoom for star detail (was 0.5)
      controls.maxDistance = 1000;  // Allow much farther zoom (was 800)
      controls.autoRotate = false;
      controls.autoRotateSpeed = 0.5;

      // Mouse/touch interaction
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('touchstart', onTouchStart);

      // Animation loop
      animate();

      // Generate some initial test points so screen isn't black
      // generatePoints(1000); // REMOVED: Only show real users from Back4App

      // Auto-start loading real data in background
      setTimeout(() => {
        startLoadRealDataJob();
      }, 500);

      // Window resize
      window.addEventListener('resize', onResize);

      // Keyboard shortcuts
      window.addEventListener('keydown', onKeyDown);

      // When URL hash changes (e.g. back/forward or manual edit), select that user if in universe
      window.addEventListener('hashchange', applyUserFromUrl);

      // Bottom controls suggestions: hide when user starts using controls
      function dismissControlsSuggestions() {
        const el = document.getElementById('controls-suggestions');
        if (!el || el.classList.contains('hidden')) return;
        el.classList.add('hidden');
        try { sessionStorage.setItem('controlsSuggestionsDismissed', '1'); } catch (e) {}
        controls.removeEventListener('start', dismissControlsSuggestions);
      }
      if (!sessionStorage.getItem('controlsSuggestionsDismissed')) {
        controls.addEventListener('start', dismissControlsSuggestions);
        renderer.domElement.addEventListener('wheel', dismissControlsSuggestions, { once: true });
        renderer.domElement.addEventListener('click', dismissControlsSuggestions, { once: true });
      } else {
        const el = document.getElementById('controls-suggestions');
        if (el) el.classList.add('hidden');
      }
    }

    // Store point metadata for interaction
    let pointMetadata = [];
    let selectedMemberIndex = null;

    // Incremental enrichment tracking
    const loadedMemberIds = new Set();
    const memberIndexMap = new Map(); // objectId -> array index
    // Single active connection line (one star at a time, updates live with positions)
    let activeConnectionLine = null; // { lineSegments, sourceId, targetIds }
    const connectionLines = new Map(); // kept as empty stub so clearConnectionLines still works

    // Orbiting post-planets (one shared Points object, ‚â§100 vertices)
    let orbitingPosts = null;       // THREE.Points
    let orbitData = [];             // [{ angle, speed, radius, tiltX, tiltZ, postId, createdAt }]
    let orbitHostId = null;         // which member's posts are orbiting
    let selectedPlanetIndex = -1;   // which planet is halo'd (-1 = none)

    // Selected-member overlay: floating label + profile picture sprite
    let selectedLabel = null;       // DOM div ‚Äî username floating over star
    let selectedSprite = null;      // THREE.Sprite ‚Äî profile pic rendered on star
    const _projectVec = new THREE.Vector3(); // reused each frame ‚Äî no alloc in hot path

    // Background jobs system
    let jobs = [];
    let jobIdCounter = 0;

    // Custom shaders for star appearance
    const starVertexShader = `
      attribute float size;
      attribute vec3 color;
      attribute float activity;
      attribute float vertexIndex;

      varying vec3 vColor;
      varying float vActivity;
      varying float vIsSelected;
      varying float vCamDist;

      uniform float time;
      uniform float selectedIndex;

      void main() {
        vColor = color;
        vActivity = activity;
        vIsSelected = (vertexIndex == selectedIndex) ? 1.0 : 0.0;

        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        float camDist = length(mvPosition.xyz);
        vCamDist = camDist;

        // Distance-based LOD
        // Far (250+): larger minimum so stars stay visible and bright from distance
        // Close (30-): boost for detail
        float lodFactor = smoothstep(250.0, 30.0, camDist);
        float finalSize = size * mix(2.0, 6.0, lodFactor); // min raised 0.6‚Üí2.0 for far visibility

        // Add extra boost for close-up views (within 30 units)
        if (camDist < 30.0) {
          float closeBoost = smoothstep(30.0, 0.1, camDist);
          finalSize *= mix(1.0, 33.0, closeBoost); // Up to 100x total when very close
        }

        // Enforce minimum size of 1.5px (subtle dots at extreme distances)
        finalSize = max(finalSize, 1.5);

        // Activity pulsing (subtle)
        float pulsePhase = position.x + position.y; // Randomize timing
        float pulse = sin(time * 1.5 + pulsePhase) * 0.15 + 0.85;
        finalSize *= mix(1.0, pulse, vActivity * 0.3);

        // Boost size for selected star
        if (vIsSelected > 0.5) {
          finalSize *= 1.8; // 80% larger
        }

        gl_PointSize = finalSize;
        gl_Position = projectionMatrix * mvPosition;
      }
    `;

    const starFragmentShader = `
      varying vec3 vColor;
      varying float vActivity;
      varying float vIsSelected;
      varying float vCamDist;

      uniform float time;

      void main() {
        vec2 coord = gl_PointCoord * 2.0 - 1.0;
        float dist = length(coord);

        float core      = 1.0 - smoothstep(0.0,  0.2,  dist);
        float innerGlow = 1.0 - smoothstep(0.2,  0.5,  dist);
        float outerGlow = 1.0 - smoothstep(0.5,  0.85, dist);

        // Distance brightness boost: stars 3√ó brighter when viewed from afar
        // distBoost goes 0‚Üí1 as camDist 30‚Üí250, then stays 1 beyond 250
        float distBoost = smoothstep(30.0, 250.0, vCamDist);
        float brightMult = mix(1.0, 3.0, distBoost);

        float brightness = (core * 1.8 + innerGlow * 0.5 + outerGlow * 0.35) * brightMult;
        float alpha      = (core * 1.0 + innerGlow * 0.8 + outerGlow * 0.4)  * brightMult;

        if (dist > 0.85) discard;

        // Mild fog only ‚Äî reduced so distant stars stay vivid
        float depth = gl_FragCoord.z / gl_FragCoord.w;
        float fogFactor = smoothstep(80.0, 400.0, depth);
        alpha *= (1.0 - fogFactor * 0.35);

        vec3 finalColor = vColor * brightness;

        if (vIsSelected > 0.5) {
          float pulseGlow = sin(time * 3.0) * 0.3 + 0.7;
          float selectionGlow = 1.0 - smoothstep(0.0, 1.0, dist);
          alpha = mix(alpha, alpha + selectionGlow * 0.5, pulseGlow);
          finalColor *= 1.3;
        }

        gl_FragColor = vec4(finalColor, clamp(alpha, 0.0, 1.0));
      }
    `;

    function generatePoints(count) {
      console.time(`generate-${count}`);

      // Remove old points
      if (points) {
        scene.remove(points);
        points.geometry.dispose();
        points.material.dispose();
      }

      // Clear metadata
      pointMetadata = [];

      // Create buffers
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      const activities = new Float32Array(count);
      const vertexIndices = new Float32Array(count);

      // Generate random spherical distribution (mimics real data)
      for (let i = 0; i < count; i++) {
        // Spherical coords with clustering
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 50 + Math.random() * 60; // radius 50-110 (wider spread)

        // Add some clustering (simulate neighborhoods)
        const clusterId = Math.floor(Math.random() * 10);
        const clusterOffset = clusterId * 24;
        const clusterTheta = Math.random() * Math.PI * 2;
        const clusterR = Math.random() * 18;

        const x = r * Math.sin(phi) * Math.cos(theta) + clusterR * Math.cos(clusterTheta);
        const y = r * Math.sin(phi) * Math.sin(theta) + clusterR * Math.sin(clusterTheta);
        const z = r * Math.cos(phi) + clusterOffset;

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        // Color gradient (blue -> cyan -> yellow -> red = risk gradient)
        const risk = Math.random();
        let riskLevel = 'low';
        if (risk < 0.33) {
          // Blue to Cyan
          const t = risk * 3;
          colors[i * 3] = 0;
          colors[i * 3 + 1] = t;
          colors[i * 3 + 2] = 1;
          riskLevel = 'low';
        } else if (risk < 0.66) {
          // Cyan to Yellow
          const t = (risk - 0.33) * 3;
          colors[i * 3] = t;
          colors[i * 3 + 1] = 1;
          colors[i * 3 + 2] = 1 - t;
          riskLevel = 'medium';
        } else {
          // Yellow to Red
          const t = (risk - 0.66) * 3;
          colors[i * 3] = 1;
          colors[i * 3 + 1] = 1 - t;
          colors[i * 3 + 2] = 0;
          riskLevel = 'high';
        }

        // Size variation (based on "activity")
        const activity = Math.floor(Math.random() * 100);
        sizes[i] = 2 + Math.log(activity + 1) * 0.5;
        activities[i] = activity / 100; // Normalize to 0-1
        vertexIndices[i] = i; // Sequential index

        // Store metadata for this point
        pointMetadata.push({
          id: `member_${i}`,
          username: `User${i}`,
          profilePicture: null, // Synthetic data has no profile pictures
          position: { x, y, z }, // Store as numbers for zoom functionality
          risk: (risk * 100).toFixed(0),
          riskLevel,
          activity,
          sobrietyDays: Math.floor(Math.random() * 365),
          cluster: `Cluster ${clusterId}`,
        });
      }

      // Create geometry
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geometry.setAttribute('activity', new THREE.BufferAttribute(activities, 1));
      geometry.setAttribute('vertexIndex', new THREE.BufferAttribute(vertexIndices, 1));

      // Create custom shader material
      const material = new THREE.ShaderMaterial({
        vertexShader: starVertexShader,
        fragmentShader: starFragmentShader,
        uniforms: {
          time: { value: 0 },
          selectedIndex: { value: -1.0 }
        },
        transparent: true,
        depthWrite: false,
        blending: THREE.NormalBlending, // Changed from AdditiveBlending to prevent white ball effect
      });

      // Create points
      points = new THREE.Points(geometry, material);
      scene.add(points);

      // Update stats
      document.getElementById('count').textContent = count.toLocaleString();

      // Calculate memory (rough estimate)
      const geomMemory = (positions.byteLength + colors.byteLength + sizes.byteLength) / 1024 / 1024;
      document.getElementById('geom').textContent = geomMemory.toFixed(2) + ' MB';

      console.timeEnd(`generate-${count}`);
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Show pointer cursor when hovering over a beam
      if (activeConnectionLine && renderer) {
        raycaster.setFromCamera(mouse, camera);
        const prevT = raycaster.params.Line.threshold;
        raycaster.params.Line.threshold = 1.2;
        const hits = raycaster.intersectObject(activeConnectionLine.lineSegments);
        raycaster.params.Line.threshold = prevT;
        renderer.domElement.style.cursor = hits.length > 0 ? 'pointer' : '';
      }
    }

    function onMouseDown(event) {
      _mouseDownX = event.clientX;
      _mouseDownY = event.clientY;
      _isDrag = false;
    }

    function onMouseClick(event) {
      // Suppress if this was a drag (orbit/pan gesture)
      const dx = event.clientX - _mouseDownX;
      const dy = event.clientY - _mouseDownY;
      if (Math.sqrt(dx * dx + dy * dy) > DRAG_THRESHOLD) return;

      if (!points) return;

      raycaster.setFromCamera(mouse, camera);

      // Check orbiting planets first ‚Äî sprites use intersectObjects on group children
      if (orbitingPosts && orbitingPosts.children.length > 0) {
        const planetHits = raycaster.intersectObjects(orbitingPosts.children, false);
        if (planetHits.length > 0) {
          const sprite = planetHits[0].object;
          const idx = sprite.userData.index;
          // Highlight selected planet (scale up slightly)
          if (selectedPlanetIndex >= 0 && selectedPlanetIndex < orbitingPosts.children.length) {
            const prev = orbitingPosts.children[selectedPlanetIndex];
            if (prev) { const s = prev.userData._baseScale || 1; prev.scale.set(s, s, 1); }
          }
          selectedPlanetIndex = idx;
          sprite.userData._baseScale = sprite.scale.x;
          sprite.scale.set(sprite.scale.x * 1.35, sprite.scale.y * 1.35, 1);

          const od = orbitData[idx];
          if (od && od.postId) {
            expandPost(od.postId, orbitHostId);
          }
          return; // don't also select the star behind it
        }
      }

      // Check connection beams ‚Äî clicking a beam travels to the target star
      if (activeConnectionLine) {
        const prevLineThreshold = raycaster.params.Line.threshold;
        raycaster.params.Line.threshold = 1.2; // generous hit area for thick glow beams
        const beamHits = raycaster.intersectObject(activeConnectionLine.lineSegments);
        raycaster.params.Line.threshold = prevLineThreshold;
        if (beamHits.length > 0) {
          // Each segment is 2 vertices; faceIndex / 1 gives segment index
          const segIdx = Math.floor(beamHits[0].index / 2);
          const targetIdx = activeConnectionLine.targetIndices[segIdx];
          if (targetIdx !== undefined) {
            flashPoint(targetIdx);
          }
          return;
        }
      }

      // Otherwise check member stars
      const intersects = raycaster.intersectObject(points);

      if (intersects.length > 0) {
        const point = intersects[0];
        const index = point.index;
        flashPoint(index);
      }
    }

    function onTouchStart(event) {
      if (event.touches.length === 1) {
        mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
      }
    }

    // Build a circular canvas texture from an image URL for the sprite (aspect-fill / cover)
    function createProfileSprite(imageUrl, username, forMemberIndex) {
      const SIZE = 128;
      const canvas = document.createElement('canvas');
      canvas.width = SIZE;
      canvas.height = SIZE;
      const ctx = canvas.getContext('2d');
      const cx = SIZE / 2;
      const R = (SIZE / 2) * (2 / 3);
      const PAD = SIZE / 2 - R;
      const diam = SIZE - PAD * 2;

      function finalize(drawFn) {
        ctx.clearRect(0, 0, SIZE, SIZE);
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cx, R, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
        drawFn(PAD, R);
        ctx.restore();
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cx, R, 0, Math.PI * 2);
        ctx.stroke();

        const texture = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          depthWrite: false,
          depthTest: false,
          blending: THREE.NormalBlending,
        });
        const sprite = new THREE.Sprite(mat);
        sprite.renderOrder = 10;
        sprite.scale.set(0.7, 0.7, 1.0);
        return sprite;
      }

      function drawImageCover(img, pad, r) {
        const w = img.naturalWidth || img.width || 1;
        const h = img.naturalHeight || img.height || 1;
        const scale = Math.max(diam / w, diam / h);
        const dw = w * scale;
        const dh = h * scale;
        ctx.drawImage(img, cx - dw / 2, cx - dh / 2, dw, dh);
      }

      function tryPlaceSprite(sprite) {
        if (forMemberIndex !== undefined && selectedMemberIndex !== forMemberIndex) {
          sprite.material.map.dispose();
          sprite.material.dispose();
          return;
        }
        placeSprite(sprite);
      }

      if (imageUrl) {
        const img = new Image();
        loadImageWithBlobFallback(img, imageUrl,
          () => {
            try {
              const sprite = finalize(() => drawImageCover(img, PAD, R));
              tryPlaceSprite(sprite);
            } catch (e) {
              const sprite = finalize((pad) => drawInitialsOnCanvas(ctx, SIZE, pad, username));
              tryPlaceSprite(sprite);
            }
          },
          () => {
            const sprite = finalize((pad) => drawInitialsOnCanvas(ctx, SIZE, pad, username));
            tryPlaceSprite(sprite);
          },
          { forCanvas: true }
        );
      } else {
        const sprite = finalize((pad) => drawInitialsOnCanvas(ctx, SIZE, pad, username));
        tryPlaceSprite(sprite);
      }
    }

    function drawInitialsOnCanvas(ctx, size, pad, username) {
      // Fill only the inset area
      ctx.fillStyle = '#1a1a3a';
      ctx.fillRect(pad, pad, size - pad * 2, size - pad * 2);
      ctx.fillStyle = '#ffffff';
      ctx.font = `bold ${(size - pad * 2) * 0.38}px system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(getInitials(username), size / 2, size / 2);
    }

    function placeSprite(sprite) {
      // Only place if this sprite is still the active one (user may have changed)
      if (!selectedSprite || selectedSprite._disposed) {
        // selectedSprite was cleared ‚Äî dispose this late-arriving sprite
        sprite.material.map.dispose();
        sprite.material.dispose();
        return;
      }
      // Remove and dispose whatever sprite is currently placed (placeholder or real initials)
      if (selectedSprite !== sprite) {
        scene.remove(selectedSprite);
        if (!selectedSprite._placeholder && selectedSprite.material) {
          if (selectedSprite.material.map) selectedSprite.material.map.dispose();
          selectedSprite.material.dispose();
        }
        selectedSprite._disposed = true;
      }
      selectedSprite = sprite;
      // Position at current host location
      if (selectedMemberIndex !== null && points) {
        const posArr = points.geometry.attributes.position.array;
        sprite.position.set(
          posArr[selectedMemberIndex * 3],
          posArr[selectedMemberIndex * 3 + 1],
          posArr[selectedMemberIndex * 3 + 2]
        );
      }
      scene.add(sprite);
    }

    let _currentProfileBlobUrl = null;

    function clearSelectedOverlay() {
      if (_currentProfileBlobUrl) {
        URL.revokeObjectURL(_currentProfileBlobUrl);
        _currentProfileBlobUrl = null;
      }
      if (selectedSprite) {
        scene.remove(selectedSprite);
        if (selectedSprite.material) {
          if (selectedSprite.material.map) selectedSprite.material.map.dispose();
          selectedSprite.material.dispose();
        }
        selectedSprite._disposed = true;
        selectedSprite = null;
      }
      const lbl = document.getElementById('star-label');
      if (lbl) lbl.style.display = 'none';
      selectedLabel = null;
    }

    function getUserIdFromUrl() {
      const hash = location.hash.slice(1).replace(/^\//, '');
      return hash || null;
    }

    function setUrlForUser(userId) {
      const base = location.pathname + location.search;
      if (userId) {
        history.replaceState(null, '', base + '#/' + encodeURIComponent(userId));
      } else {
        history.replaceState(null, '', base);
      }
    }

    function applyUserFromUrl() {
      if (!points || !pointMetadata.length) return;
      const userId = getUserIdFromUrl();
      if (!userId) return;
      const idx = memberIndexMap.get(decodeURIComponent(userId));
      if (idx === undefined || idx === selectedMemberIndex) return;
      flashPoint(idx);
    }

    function flashPoint(index) {
      // Show detail panel
      const metadata = pointMetadata[index];
      if (!metadata) return;
      _dbgLog('flashPoint idx=' + index + ' id=' + metadata.id);

      // Close any expanded post view ‚Äî switching star goes back to member view
      const expandedView = document.getElementById('post-expanded');
      if (expandedView) expandedView.classList.remove('visible');

      // Reset supporter cards while new profile loads
      const suppSec = document.getElementById('supporters-section');
      if (suppSec) suppSec.style.display = 'none';

      // Blur the sidebar when transitioning between users (already visible)
      const detailEl = document.getElementById('detail');
      const alreadyOpen = detailEl.classList.contains('visible');
      if (alreadyOpen) {
        detailEl.classList.add('content-transitioning');
      }

      const prevIndex = selectedMemberIndex;
      selectedMemberIndex = index;

      // Update shader uniform for selection halo
      if (points && points.material && points.material.uniforms) {
        points.material.uniforms.selectedIndex.value = index;
      }

      // Clear any existing overlay from previous selection
      clearSelectedOverlay();

      // Show floating username label (positioned every frame in animate)
      const lblEl = document.getElementById('star-label');
      const lblText = document.getElementById('star-label-text');
      const lblPip = document.getElementById('star-label-pip');
      selectedLabel = lblEl;

      // Update profile picture/avatar with smooth loading
      const avatar = document.getElementById('detail-avatar');
      const username = metadata.username || metadata.id;

      const imageUrl = getProfilePictureUrl(metadata.profilePicture);

      // Set up floating label color to match risk level
      const riskColors = { low: '#3CDC78', medium: '#FFD580', high: '#FF5038' };
      const pipColor = riskColors[metadata.riskLevel] || '#ffffff';
      lblText.textContent = '@' + username;
      lblPip.style.background = pipColor;
      lblEl.style.display = 'block';

      selectedSprite = { _placeholder: true, _disposed: false };

      if (imageUrl) {
        avatar.classList.add('loading');
        avatar.textContent = '';
        // Fetch once with CORS and use the blob URL for BOTH sidebar and sprite.
        // The sprite needs a same-origin (blob) URL to draw to canvas; direct CDN URL often fails CORS for canvas.
        fetch(imageUrl, { mode: 'cors' })
          .then(r => r.ok ? r.blob() : Promise.reject(r.status))
          .then(blob => {
            if (selectedMemberIndex !== index) return;
            const blobUrl = URL.createObjectURL(new Blob([blob], { type: 'image/jpeg' }));
            if (_currentProfileBlobUrl) URL.revokeObjectURL(_currentProfileBlobUrl);
            _currentProfileBlobUrl = blobUrl;

            const img = document.createElement('img');
            img.alt = username;
            avatar.appendChild(img);
            img.onload = () => {
              if (selectedMemberIndex !== index) return;
              avatar.classList.remove('loading');
              img.classList.add('loaded');
            };
            img.onerror = () => {
              avatar.classList.remove('loading');
              avatar.innerHTML = '';
              avatar.textContent = getInitials(username);
            };
            img.src = blobUrl;

            createProfileSprite(blobUrl, username, index);
          })
          .catch(() => {
            if (selectedMemberIndex !== index) return;
            createProfileSprite(null, username, index);
            const img = document.createElement('img');
            img.alt = username;
            avatar.appendChild(img);
            loadImageWithBlobFallback(img, imageUrl,
              () => { avatar.classList.remove('loading'); img.classList.add('loaded'); },
              () => { avatar.classList.remove('loading'); avatar.innerHTML = ''; avatar.textContent = getInitials(username); },
              { forCanvas: false }
            );
          });
      } else {
        avatar.classList.remove('loading');
        avatar.innerHTML = '';
        avatar.textContent = getInitials(username);

        // Lazy-fetch proPic for stub users that have no profile picture yet.
        // If found, update the 3D sprite and sidebar avatar while this user is still selected.
        if (metadata.id) {
          const lazyIndex = index; // capture for stale-check
          const lazyParams = new URLSearchParams({
            where: JSON.stringify({ objectId: metadata.id }),
            keys: 'objectId,proPic,profilePicture',
            limit: '1',
          });
          fetch(`https://parseapi.back4app.com/classes/_User?${lazyParams}`, {
            headers: {
              'X-Parse-Application-Id': B4A_APP_ID,
              'X-Parse-REST-API-Key': 'rNXb9qIR6wrZ3n81OG33HVQkpPsXANUatiOE5HSq',
            }
          })
          .then(r => r.json())
          .then(data => {
            const u = data.results && data.results[0];
            if (!u) return;
            const url = getProfilePictureUrl(u.proPic || u.profilePicture);
            if (!url) return;
            if (pointMetadata[lazyIndex]) pointMetadata[lazyIndex].profilePicture = url;
            if (selectedMemberIndex !== lazyIndex) return;
            fetch(url, { mode: 'cors' })
              .then(r => r.ok ? r.blob() : Promise.reject(r.status))
              .then(blob => {
                if (selectedMemberIndex !== lazyIndex) return;
                const blobUrl = URL.createObjectURL(new Blob([blob], { type: 'image/jpeg' }));
                if (_currentProfileBlobUrl) URL.revokeObjectURL(_currentProfileBlobUrl);
                _currentProfileBlobUrl = blobUrl;
                avatar.innerHTML = '';
                avatar.classList.add('loading');
                const lazyImg = document.createElement('img');
                lazyImg.alt = username;
                avatar.appendChild(lazyImg);
                lazyImg.onload = () => { avatar.classList.remove('loading'); lazyImg.classList.add('loaded'); };
                lazyImg.onerror = () => { avatar.classList.remove('loading'); avatar.innerHTML = ''; avatar.textContent = getInitials(username); };
                lazyImg.src = blobUrl;
                createProfileSprite(blobUrl, username, lazyIndex);
              })
              .catch(() => {
                if (selectedMemberIndex !== lazyIndex) return;
                avatar.innerHTML = '';
                avatar.classList.add('loading');
                const lazyImg = document.createElement('img');
                lazyImg.alt = username;
                avatar.appendChild(lazyImg);
                loadImageWithBlobFallback(lazyImg, url, () => { avatar.classList.remove('loading'); lazyImg.classList.add('loaded'); }, () => { avatar.classList.remove('loading'); avatar.innerHTML = ''; avatar.textContent = getInitials(username); }, { forCanvas: false });
                createProfileSprite(null, username, lazyIndex);
              });
          })
          .catch(() => { /* ignore */ });
        }
      }

      document.getElementById('detail-id').textContent = metadata.id;
      document.getElementById('detail-username').textContent = `@${username}`;
      document.getElementById('detail-username-full').textContent = `@${username}`;

      // Safely handle position display
      if (metadata.position) {
        document.getElementById('detail-pos').textContent = `(${metadata.position.x.toFixed(1)}, ${metadata.position.y.toFixed(1)}, ${metadata.position.z.toFixed(1)})`;
      } else {
        document.getElementById('detail-pos').textContent = 'N/A';
      }

      const riskSpan = document.getElementById('detail-risk');
      riskSpan.textContent = `${metadata.risk}% (${metadata.riskLevel})`;
      riskSpan.className = `risk-${metadata.riskLevel}`;

      // Show/hide risk explanation based on risk level
      const riskExplanation = document.getElementById('risk-explanation');
      const riskExplanationText = document.getElementById('risk-explanation-text');

      if (metadata.riskLevel === 'high') {
        // Generate explanation based on risk factors
        const explanation = generateRiskExplanation(metadata);
        riskExplanationText.textContent = explanation;
        riskExplanation.style.display = 'block';
      } else {
        riskExplanation.style.display = 'none';
      }

      document.getElementById('detail-activity').textContent = `${metadata.activity} posts/comments`;
      document.getElementById('detail-cluster').textContent = metadata.cluster;
      document.getElementById('detail-sobriety').textContent = metadata.sobrietyDays > 0
        ? `${metadata.sobrietyDays.toLocaleString()} days`
        : (metadata.sobrietyDate || metadata.sobriety ? '< 1 day' : 'Not set');

      detailEl.classList.add('visible');
      // Mobile bottom sheet: start at 1/3 height so user can scroll up for full details
      if (window.innerWidth <= 768) {
        detailEl.classList.remove('detail-expanded');
      }

      // Update URL so this user can be revisited via the same link
      setUrlForUser(metadata.id);

      // Remove blur after content is swapped ‚Äî triggers fade-back-in transition
      if (alreadyOpen) {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            detailEl.classList.remove('content-transitioning');
          });
        });
      }

      // Prioritize profile picture: delay posts so profile pic request wins the connection pool
      const PROFILE_PRIORITY_DELAY_MS = 400;
      setTimeout(() => loadUserPosts(metadata.id), PROFILE_PRIORITY_DELAY_MS);

      // Draw connection lines to users this person has commented to
      drawConnectionLines(metadata.id);

      // Zoom close to the selected star
      if (!points || !points.geometry || !points.geometry.attributes.position) {
        console.error('Points geometry not initialized');
        return;
      }

      const positions = points.geometry.attributes.position.array;
      if (index * 3 + 2 >= positions.length) {
        console.error(`Invalid index ${index} for positions array of length ${positions.length}`);
        return;
      }

      const targetPos = new THREE.Vector3(
        positions[index * 3],
        positions[index * 3 + 1],
        positions[index * 3 + 2]
      );

      // Skip zoom only when re-selecting the same star we're already viewing
      const distToTarget = camera.position.distanceTo(targetPos);
      if (prevIndex === index && distToTarget <= 12) return; // same star, already zoomed ‚Äî don't re-animate

      const endPos = targetPos.clone().add(new THREE.Vector3(3, 3, 5));
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();

      let t = 0;
      const animateZoom = () => {
        t += 0.03;
        if (t > 1) t = 1;

        camera.position.lerpVectors(startPos, endPos, t);
        controls.target.lerpVectors(startTarget, targetPos, t);
        controls.update();

        if (t < 1) requestAnimationFrame(animateZoom);
      };
      animateZoom();
    }

    function generateRiskExplanation(metadata) {
      const factors = [];

      // Low sobriety days
      if (metadata.sobrietyDays < 90) {
        factors.push('early recovery stage (under 90 days)');
      }

      // Low activity
      if (metadata.activity < 10) {
        factors.push('minimal community engagement');
      }

      // High risk score
      if (metadata.risk > 70) {
        factors.push('elevated risk indicators from behavior patterns');
      }

      // Default explanation if no specific factors
      if (factors.length === 0) {
        return 'This user shows multiple risk indicators that suggest they may benefit from additional support and monitoring.';
      }

      // Build explanation
      const factorList = factors.join(', ');
      return `This user is flagged as high risk due to ${factorList}. They may benefit from closer community support and outreach.`;
    }

    window.closeDetail = () => {
      const detailEl = document.getElementById('detail');
      detailEl.classList.remove('visible', 'detail-expanded');
      selectedMemberIndex = null;

      // Clear user from URL so root URL shows no selection
      setUrlForUser(null);

      // Clear selection halo
      if (points && points.material && points.material.uniforms) {
        points.material.uniforms.selectedIndex.value = -1.0;
      }

      // Remove orbiting post-planets
      clearOrbitingPosts();

      // Remove floating label and profile sprite
      clearSelectedOverlay();

      // Remove connection lines
      clearActiveConnectionLine();

      // Hide supporter cards
      const suppSec = document.getElementById('supporters-section');
      if (suppSec) suppSec.style.display = 'none';
    };

    function initDetailBottomSheet() {
      const detailEl = document.getElementById('detail');
      const handle = document.getElementById('detail-drag-handle');
      if (!detailEl || !handle) return;
      const MOBILE_BREAKPOINT = 768;
      let dragStartY = 0;
      let dragStartExpanded = false;
      let dragDidExpand = false;
      let dragDidCollapse = false;
      let dragDidClose = false;

      function isMobile() {
        return window.innerWidth <= MOBILE_BREAKPOINT;
      }

      handle.addEventListener('pointerdown', (e) => {
        if (!isMobile() || !detailEl.classList.contains('visible')) return;
        e.preventDefault();
        dragStartY = e.clientY;
        dragStartExpanded = detailEl.classList.contains('detail-expanded');
        dragDidExpand = false;
        dragDidCollapse = false;
        dragDidClose = false;
        handle.setPointerCapture(e.pointerId);
      });
      handle.addEventListener('pointermove', (e) => {
        if (!isMobile() || !detailEl.classList.contains('visible')) return;
        const dy = e.clientY - dragStartY;
        if (dragStartExpanded) {
          if (dy > 30 && !dragDidCollapse) {
            detailEl.classList.remove('detail-expanded');
            dragDidCollapse = true;
          }
        } else {
          if (dy < -25 && !dragDidExpand) {
            detailEl.classList.add('detail-expanded');
            dragDidExpand = true;
          } else if (dy > 80 && !dragDidClose) {
            closeDetail();
            dragDidClose = true;
          }
        }
      });
      handle.addEventListener('pointerup', (e) => {
        handle.releasePointerCapture(e.pointerId);
      });

      detailEl.addEventListener('scroll', () => {
        if (!isMobile() || !detailEl.classList.contains('visible')) return;
        if (detailEl.classList.contains('detail-expanded') && detailEl.scrollTop <= 0) {
          detailEl.dataset.atTop = '1';
        } else {
          delete detailEl.dataset.atTop;
        }
        if (!detailEl.classList.contains('detail-expanded') && detailEl.scrollTop > 60) {
          detailEl.classList.add('detail-expanded');
        }
      }, { passive: true });
      detailEl.addEventListener('touchstart', (e) => {
        if (!isMobile() || !detailEl.classList.contains('visible')) return;
        detailEl.dataset.touchStartY = e.touches[0].clientY;
        detailEl.dataset.touchStartScroll = String(detailEl.scrollTop);
      }, { passive: true });
      detailEl.addEventListener('touchmove', (e) => {
        if (!isMobile() || !detailEl.classList.contains('visible')) return;
        const atTop = detailEl.scrollTop <= 0;
        const startY = Number(detailEl.dataset.touchStartY);
        const dy = e.touches[0].clientY - startY;
        if (detailEl.classList.contains('detail-expanded')) {
          if (atTop && dy > 40) {
            detailEl.classList.remove('detail-expanded');
            detailEl.dataset.touchStartY = e.touches[0].clientY;
          }
        } else {
          if (atTop && dy > 60) closeDetail();
        }
      }, { passive: true });
    }
    initDetailBottomSheet();

    let currentSearchResults = [];
    let selectedSearchIndex = -1;

    let searchAbortController = null;

    // Actual search function (will be debounced)
    async function performSearch(query, dropdown) {
      const queryLower = query.toLowerCase();

      // Check cache first (version must match so we don't use stale profile picture shape)
      const cacheKey = queryLower;
      const cached = searchCache.get(cacheKey);
      if (cached && cached.version === SEARCH_CACHE_VERSION && (Date.now() - cached.timestamp) < SEARCH_CACHE_DURATION) {
        currentSearchResults = cached.results;
        selectedSearchIndex = -1;
        renderSearchResults(currentSearchResults, queryLower);
        dropdown.classList.add('visible');
        return;
      }

      // Cancel previous search
      if (searchAbortController) {
        searchAbortController.abort();
      }
      searchAbortController = new AbortController();

      // Keep existing results visible while loading ‚Äî just add a subtle indicator
      // (don't blank the dropdown ‚Äî keeps it populated on new search)
      if (currentSearchResults.length === 0) {
        dropdown.innerHTML = '<div style="padding: 12px; text-align: center; color: #999; font-size: 13px;">Searching‚Ä¶</div>';
        dropdown.classList.add('visible');
      } else {
        // Already showing results ‚Äî add a faint "refreshing" indicator at the top
        const existing = dropdown.querySelector('.search-refreshing');
        if (!existing) {
          const indicator = document.createElement('div');
          indicator.className = 'search-refreshing';
          indicator.style.cssText = 'padding: 4px 16px; font-size: 11px; color: rgba(167,139,250,0.6); border-bottom: 1px solid rgba(255,255,255,0.04);';
          indicator.textContent = 'Updating‚Ä¶';
          dropdown.prepend(indicator);
        }
        dropdown.classList.add('visible');
      }

      try {
        // Search Back4App for members (use GET, order by TotalComments for engagement-based ranking)
        const params = new URLSearchParams({
          where: JSON.stringify({
            username: {
              $regex: queryLower,
              $options: 'i'
            }
          }),
          order: '-TotalComments',
          limit: '10',
          keys: 'username,objectId,proPic,profilePicture,sobrietyDate,TotalComments'
        });

        const response = await fetch(`https://parseapi.back4app.com/classes/_User?${params}`, {
          method: 'GET',
          headers: {
            'X-Parse-Application-Id': 'Wuo5quzr8f2vZDeSSskftVcDKPUpm16VHdDLm3by',
            'X-Parse-REST-API-Key': 'rNXb9qIR6wrZ3n81OG33HVQkpPsXANUatiOE5HSq'
          },
          signal: searchAbortController.signal
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          console.error('Search failed:', response.status, errorData);
          throw new Error(`Search failed: ${response.status} ${errorData.error || response.statusText}`);
        }

        const data = await response.json();
        const matches = data.results.map(member => {
          const existingIndex = pointMetadata.findIndex(m => m.id == member.objectId);
          const fileObj = member.proPic || member.profilePicture;
          return {
            member: {
              id: member.objectId,
              username: member.username || 'Anonymous',
              profilePicture: fileObj || null,
              sobrietyDate: member.sobrietyDate?.iso ?? null,
              sobrietyDays: member.sobrietyDate?.iso
                ? Math.floor((Date.now() - new Date(member.sobrietyDate.iso).getTime()) / 86400000)
                : 0,
              cluster: 'Search Result',
              activity: 0,
              risk: 50,
              riskLevel: 'medium',
              totalComments: member.TotalComments || 0
            },
            index: existingIndex, // Will be -1 if not in universe
            isNew: existingIndex === -1
          };
        });

        // Sort by relevance: exact match > starts with > contains, then by TotalComments
        matches.sort((a, b) => {
          const usernameA = (a.member.username || '').toLowerCase();
          const usernameB = (b.member.username || '').toLowerCase();
          const query = queryLower;

          // Exact match priority
          const exactA = usernameA === query ? 3 : 0;
          const exactB = usernameB === query ? 3 : 0;
          if (exactA !== exactB) return exactB - exactA;

          // Starts with priority
          const startsA = usernameA.startsWith(query) ? 2 : 0;
          const startsB = usernameB.startsWith(query) ? 2 : 0;
          if (startsA !== startsB) return startsB - startsA;

          // Then by engagement (TotalComments descending)
          return (b.member.totalComments || 0) - (a.member.totalComments || 0);
        });

        currentSearchResults = matches;
        selectedSearchIndex = -1;

        // Cache the results
        searchCache.set(queryLower, {
          results: matches,
          timestamp: Date.now(),
          version: SEARCH_CACHE_VERSION
        });

        if (currentSearchResults.length > 0) {
          renderSearchResults(currentSearchResults, queryLower);
          dropdown.classList.add('visible');
        } else {
          dropdown.innerHTML = '<div style="padding: 12px; text-align: center; color: #999; font-size: 13px;">No users found</div>';
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Search error:', error);
          // On error: keep previous results if available, just remove updating indicator
          const indicator = dropdown.querySelector('.search-refreshing');
          if (indicator) indicator.remove();
          if (currentSearchResults.length === 0) {
            dropdown.innerHTML = '<div style="padding: 12px; text-align: center; color: #ff4444; font-size: 13px;">Search error</div>';
          }
        }
      }
    }

    // Debounced search handler
    const debouncedSearch = debounce(performSearch, SEARCH_DEBOUNCE_DELAY);

    // Helper: retry loading an <img> via fetch+blob when direct src fails due to wrong
    // MIME type (e.g. images stored with _image.txt extension served as text/plain).
    // Fallback text is read from data-fallback attribute on the parent element to avoid
    // quote-escaping issues when embedding text in inline onerror handlers.
    window._imgBlobFallback = (imgEl) => {
      const url = imgEl.getAttribute('data-src') || imgEl.src;
      const fallbackText = imgEl.parentElement ? (imgEl.parentElement.getAttribute('data-fallback-text') || '') : '';
      const fallbackHtml = fallbackText ? `<div class="post-text">${fallbackText}</div>` : '';
      if (!url || imgEl._blobAttempted) { if (fallbackHtml) imgEl.outerHTML = fallbackHtml; return; }
      imgEl._blobAttempted = true;
      fetch(url, { mode: 'cors' })
        .then(r => r.ok ? r.blob() : Promise.reject(r.status))
        .then(blob => {
          const objectUrl = URL.createObjectURL(new Blob([blob], { type: 'image/jpeg' }));
          imgEl.onload = () => {};
          imgEl.onerror = () => { URL.revokeObjectURL(objectUrl); if (fallbackHtml) imgEl.outerHTML = fallbackHtml; };
          imgEl.src = objectUrl;
        })
        .catch(() => { if (fallbackHtml) imgEl.outerHTML = fallbackHtml; });
    };

    /**
     * Load an image into an img element. Use forCanvas: true only when drawing to canvas (sprite, planets).
     * - forCanvas false (display only): no crossOrigin ‚Äî image can load from CDNs that don't send CORS for GET.
     * - forCanvas true: crossOrigin anonymous + blob fallback for wrong MIME; required so canvas is not tainted.
     */
    function loadImageWithBlobFallback(img, url, onLoad, onError, options) {
      const forCanvas = options && options.forCanvas;
      if (!url) { if (onError) onError(); return; }
      if (forCanvas) img.crossOrigin = 'anonymous';
      img.onload = () => {
        if (img._blobUrl) { URL.revokeObjectURL(img._blobUrl); img._blobUrl = null; }
        if (onLoad) onLoad();
      };
      img.onerror = () => {
        if (!forCanvas) { if (onError) onError(); return; }
        if (img._blobAttempted) { if (onError) onError(); return; }
        img._blobAttempted = true;
        fetch(url, { mode: 'cors' })
          .then(r => r.ok ? r.blob() : Promise.reject(r.status))
          .then(blob => {
            const objectUrl = URL.createObjectURL(new Blob([blob], { type: 'image/jpeg' }));
            img._blobUrl = objectUrl;
            img.onload = () => {
              URL.revokeObjectURL(objectUrl);
              img._blobUrl = null;
              if (onLoad) onLoad();
            };
            img.onerror = () => {
              URL.revokeObjectURL(objectUrl);
              img._blobUrl = null;
              if (onError) onError();
            };
            img.src = objectUrl;
          })
          .catch(() => { if (onError) onError(); });
      };
      img.src = url;
    }

    const B4A_APP_ID = 'Wuo5quzr8f2vZDeSSskftVcDKPUpm16VHdDLm3by';
    const B4A_PARSEFILES_BASE = 'https://parsefiles.back4app.com/' + B4A_APP_ID + '/';

    /** Get profile picture URL from Parse File (proPic/profilePicture). Prefer .url from the Parse file. */
    function getProfilePictureUrl(fileObj) {
      if (!fileObj) return null;
      if (typeof fileObj === 'string' && fileObj) return fileObj;
      if (fileObj && typeof fileObj === 'object') {
        if (fileObj.url) return fileObj.url;
        if (fileObj.uri) return fileObj.uri;
        if (fileObj.name) return B4A_PARSEFILES_BASE + encodeURIComponent(fileObj.name);
      }
      return null;
    }

    // Main search member function with keyboard navigation
    window.searchMember = async (event) => {
      const query = event.target.value.trim();
      const dropdown = document.getElementById('search-dropdown');

      // Handle keyboard navigation (don't debounce these)
      if (event.key === 'ArrowDown') {
        event.preventDefault();
        selectedSearchIndex = Math.min(selectedSearchIndex + 1, currentSearchResults.length - 1);
        updateSearchSelection();
        return;
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        selectedSearchIndex = Math.max(selectedSearchIndex - 1, -1);
        updateSearchSelection();
        return;
      } else if (event.key === 'Enter') {
        event.preventDefault();
        if (selectedSearchIndex >= 0 && currentSearchResults[selectedSearchIndex]) {
          await selectSearchResult(currentSearchResults[selectedSearchIndex]);
        } else if (currentSearchResults.length > 0) {
          await selectSearchResult(currentSearchResults[0]);
        }
        return;
      } else if (event.key === 'Escape') {
        dropdown.classList.remove('visible');
        event.target.blur();
        return;
      }

      // Filter members as user types
      if (query.length === 0) {
        dropdown.classList.remove('visible');
        currentSearchResults = [];
        clearTimeout(searchTimeout); // Cancel pending searches
        return;
      }

      if (query.length < 2) return; // Require at least 2 characters

      // Debounced search
      debouncedSearch(query, dropdown);
    };

    function renderSearchResults(results, query) {
      const dropdown = document.getElementById('search-dropdown');
      dropdown.innerHTML = results.map((result, idx) => {
        const { member, isNew } = result;
        const username = member.username || member.id;
        const initials = getInitials(username);

        const highlightedUsername = highlightText(username, query);
        const badge = isNew ? '<span style="font-size: 10px; color: #a78bfa; margin-left: 6px;">+ Add</span>' : '';

        return `
          <div class="search-result-item ${idx === selectedSearchIndex ? 'selected' : ''}"
               onclick="window.selectSearchResultByIndex(${idx})"
               data-index="${idx}">
            <div class="search-result-avatar loading" data-avatar-id="avatar-${idx}" data-user-id="${member.id}">
              ${initials}
            </div>
            <div class="search-result-info">
              <div class="search-result-username">@${highlightedUsername}${badge}</div>
              <div class="search-result-meta">
                ${member.sobrietyDays} days sober ‚Ä¢ ${member.totalComments || 0} comments
              </div>
            </div>
          </div>
        `;
      }).join('');

      // 1) Use search response URLs immediately (display-only, no CORS so CDN works).
      results.forEach((result, idx) => {
        const url = getProfilePictureUrl(result.member.profilePicture);
        const avatarId = `avatar-${idx}`;
        const username = result.member.username || result.member.id;
        if (url) loadAvatarImage(url, avatarId, username, result.member.id);
      });
      // 2) Batch-fetch full _User docs in parallel; fill in any that didn't load from search.
      fetchSearchResultProPicsBatch(results);
    }

    /** Batch fetch proPic; only update avatars that are still loading (no image loaded yet). */
    function fetchSearchResultProPicsBatch(results) {
      if (!results.length) return;
      const ids = results.map(r => r.member.id);
      const params = new URLSearchParams({
        where: JSON.stringify({ objectId: { $in: ids } }),
        limit: String(ids.length),
      });
      fetch(`https://parseapi.back4app.com/classes/_User?${params}`, {
        headers: {
          'X-Parse-Application-Id': B4A_APP_ID,
          'X-Parse-REST-API-Key': 'rNXb9qIR6wrZ3n81OG33HVQkpPsXANUatiOE5HSq',
        },
      })
        .then(r => r.json())
        .then(data => {
          const picById = {};
          (data.results || []).forEach(u => {
            const url = getProfilePictureUrl(u.proPic || u.profilePicture);
            if (url) picById[u.objectId] = url;
          });
          results.forEach((result, idx) => {
            const userId = result.member.id;
            const username = result.member.username || result.member.id;
            const url = picById[userId];
            const avatar = document.querySelector(`[data-avatar-id="avatar-${idx}"][data-user-id="${userId}"]`);
            if (!avatar || !url) {
              if (avatar && !url) {
                avatar.classList.remove('loading');
                avatar.textContent = getInitials(username);
              }
              return;
            }
            if (!avatar.classList.contains('loading')) return;
            const img = avatar.querySelector('img.loaded');
            if (img) return;
            loadAvatarImage(url, `avatar-${idx}`, username, userId);
          });
        })
        .catch(() => {
          results.forEach((result, idx) => {
            const userId = result.member.id;
            const avatar = document.querySelector(`[data-avatar-id="avatar-${idx}"][data-user-id="${userId}"]`);
            if (avatar && avatar.classList.contains('loading') && !avatar.querySelector('img.loaded')) {
              avatar.classList.remove('loading');
              avatar.textContent = getInitials(result.member.username || result.member.id);
            }
          });
        });
    }

    function loadAvatarImage(src, avatarId, username, expectedUserId) {
      const selector = expectedUserId
        ? `[data-avatar-id="${avatarId}"][data-user-id="${expectedUserId}"]`
        : `[data-avatar-id="${avatarId}"]`;
      const avatar = document.querySelector(selector);
      if (!avatar) return;

      const imageUrl = getProfilePictureUrl(src) || (typeof src === 'string' ? src : null);

      if (!imageUrl) {
        avatar.classList.remove('loading');
        avatar.textContent = getInitials(username);
        return;
      }

      avatar.querySelectorAll('img').forEach(el => el.remove());
      const img = document.createElement('img');
      img.alt = username;
      avatar.appendChild(img);
      const checkStale = () => {
        if (expectedUserId && avatar.getAttribute('data-user-id') !== expectedUserId) return true;
        return false;
      };
      loadImageWithBlobFallback(img, imageUrl,
        () => {
          if (checkStale()) return;
          avatar.classList.remove('loading');
          img.classList.add('loaded');
        },
        () => {
          if (checkStale()) return;
          avatar.classList.remove('loading');
          avatar.textContent = getInitials(username);
        },
        { forCanvas: false }
      );
    }

    function highlightText(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${query})`, 'gi');
      return text.replace(regex, '<span class="search-result-highlight">$1</span>');
    }

    function getInitials(name) {
      return name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
    }

    function updateSearchSelection() {
      const items = document.querySelectorAll('.search-result-item');
      items.forEach((item, idx) => {
        if (idx === selectedSearchIndex) {
          item.classList.add('selected');
          item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        } else {
          item.classList.remove('selected');
        }
      });
    }

    // Helper function to select search result by index (called from onclick)
    window.selectSearchResultByIndex = async function(index) {
      if (currentSearchResults && currentSearchResults[index]) {
        await selectSearchResult(currentSearchResults[index]);
      }
    };

    async function selectSearchResult(result) {
      const dropdown = document.getElementById('search-dropdown');
      const searchInput = document.querySelector('#search input');

      dropdown.classList.remove('visible');
      searchInput.value = '';

      let indexToFlash = -1;
      if (result.isNew) {
        console.log('Adding new user to universe:', result.member.username);
        indexToFlash = await addMemberToUniverse(result.member);
      } else {
        if (result.index >= 0 && result.index < pointMetadata.length) {
          const meta = pointMetadata[result.index];
          if (meta && !meta.profilePicture && result.member.profilePicture) {
            meta.profilePicture = result.member.profilePicture;
          }
        }
        indexToFlash = result.index;
      }
      if (indexToFlash >= 0 && pointMetadata[indexToFlash]) {
        flashPoint(indexToFlash);
      } else if (result.isNew) {
        console.warn('[Search] Universe not ready ‚Äî could not add user. Try again after the scene has loaded.');
      }
    }

    async function addMemberToUniverse(member) {
      if (!points || !points.geometry) {
        console.warn('[Search] Points not initialized ‚Äî cannot add user to universe yet.');
        return undefined;
      }

      // Generate random position in the universe
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 30 + Math.random() * 40;

      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.sin(phi) * Math.sin(theta);
      const z = r * Math.cos(phi);

      // Get current arrays
      const oldPositions = points.geometry.attributes.position.array;
      const oldColors = points.geometry.attributes.color.array;
      const oldSizes = points.geometry.attributes.size.array;
      const oldActivities = points.geometry.attributes.activity.array;
      const oldVertexIndices = points.geometry.attributes.vertexIndex.array;

      const newIndex = oldPositions.length / 3;

      // Create new larger arrays
      const newPositions = new Float32Array(oldPositions.length + 3);
      const newColors = new Float32Array(oldColors.length + 3);
      const newSizes = new Float32Array(oldSizes.length + 1);
      const newActivities = new Float32Array(oldActivities.length + 1);
      const newVertexIndices = new Float32Array(oldVertexIndices.length + 1);

      // Copy old data
      newPositions.set(oldPositions);
      newColors.set(oldColors);
      newSizes.set(oldSizes);
      newActivities.set(oldActivities);
      newVertexIndices.set(oldVertexIndices);

      // Add new member
      newPositions[newIndex * 3] = x;
      newPositions[newIndex * 3 + 1] = y;
      newPositions[newIndex * 3 + 2] = z;

      // Color based on risk
      const risk = member.risk / 100 || 0.5;
      if (risk < 0.33) {
        newColors[newIndex * 3] = 0;
        newColors[newIndex * 3 + 1] = risk * 3;
        newColors[newIndex * 3 + 2] = 1;
      } else if (risk < 0.66) {
        const t = (risk - 0.33) * 3;
        newColors[newIndex * 3] = t;
        newColors[newIndex * 3 + 1] = 1;
        newColors[newIndex * 3 + 2] = 1 - t;
      } else {
        const t = (risk - 0.66) * 3;
        newColors[newIndex * 3] = 1;
        newColors[newIndex * 3 + 1] = 1 - t;
        newColors[newIndex * 3 + 2] = 0;
      }

      newSizes[newIndex] = 2 + Math.log(member.activity + 1) * 0.5;
      newActivities[newIndex] = Math.min(member.activity / 100, 1);
      newVertexIndices[newIndex] = newIndex;

      // Update geometry
      points.geometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
      points.geometry.setAttribute('color', new THREE.BufferAttribute(newColors, 3));
      points.geometry.setAttribute('size', new THREE.BufferAttribute(newSizes, 1));
      points.geometry.setAttribute('activity', new THREE.BufferAttribute(newActivities, 1));
      points.geometry.setAttribute('vertexIndex', new THREE.BufferAttribute(newVertexIndices, 1));

      // Add to metadata
      pointMetadata.push({
        ...member,
        position: { x, y, z }
      });

      // Register in memberIndexMap so planets orbit at the right position
      memberIndexMap.set(member.id, newIndex);
      loadedMemberIds.add(member.id);

      console.log(`Added ${member.username} at index ${newIndex}`);
      return newIndex;
    }

    function timeAgo(iso) {
      if (!iso) return '';
      const diff = Date.now() - new Date(iso).getTime();
      const s = Math.floor(diff / 1000);
      if (s < 60)  return s + 's ago';
      const m = Math.floor(s / 60);
      if (m < 60)  return m + 'm ago';
      const h = Math.floor(m / 60);
      if (h < 24)  return h + 'h ago';
      const d = Math.floor(h / 24);
      if (d < 30)  return d + 'd ago';
      const mo = Math.floor(d / 30);
      if (mo < 12) return mo + 'mo ago';
      return Math.floor(mo / 12) + 'y ago';
    }

    // Planet texture cache: postId ‚Üí THREE.CanvasTexture (avoids re-fetching on re-select)
    const _planetTextureCache = new Map();

    function _makePlanetCanvas(size, hue) {
      // Solid colored circle ‚Äî used as placeholder while image loads
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const cx = size / 2;
      ctx.clearRect(0, 0, size, size);
      // Glow: dim in the inner 2/3 (where the image will sit), bright only in outer ring
      const grd = ctx.createRadialGradient(cx, cx, cx * 0.1, cx, cx, cx);
      grd.addColorStop(0,    `hsla(${hue},60%,30%,0.3)`);  // dark centre ‚Äî won't wash image
      grd.addColorStop(0.55, `hsla(${hue},70%,40%,0.5)`);  // transition at 2/3 boundary
      grd.addColorStop(0.7,  `hsla(${hue},85%,65%,0.9)`);  // bright outer ring starts
      grd.addColorStop(1.0,  `hsla(${hue},70%,30%,0.0)`);  // fade to transparent edge
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(cx, cx, cx, 0, Math.PI * 2);
      ctx.fill();
      return c;
    }

    function _makePlanetTextureFromImage(imgUrl, size, hue, sprite) {
      // Load post image async; update sprite texture when ready
      // No crossOrigin ‚Äî Back4App CDN doesn't always send CORS headers; without it
      // the image loads from cache and canvas draw succeeds. THREE.CanvasTexture
      // doesn't need readPixels so a tainted canvas is fine.
      const img = new Image();
      img.onload = () => {
        try {
          const c = document.createElement('canvas');
          c.width = c.height = size;
          const ctx = c.getContext('2d');
          const cx = size / 2;

          // 1. Draw planet glow background ‚Äî dim centre so image is clearly visible
          const grd = ctx.createRadialGradient(cx, cx, cx * 0.1, cx, cx, cx);
          grd.addColorStop(0,    `hsla(${hue},60%,30%,0.3)`);
          grd.addColorStop(0.55, `hsla(${hue},70%,40%,0.5)`);
          grd.addColorStop(0.7,  `hsla(${hue},85%,65%,0.9)`);
          grd.addColorStop(1.0,  `hsla(${hue},70%,30%,0.0)`);
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(cx, cx, cx, 0, Math.PI * 2);
          ctx.fill();

          // 2. Draw image inset (clipped to inner 2/3 radius circle), cover-fit
          ctx.save();
          const imgR = cx * (2 / 3);
          ctx.beginPath();
          ctx.arc(cx, cx, imgR, 0, Math.PI * 2);
          ctx.clip();
          const ar = img.width / img.height;
          const diam = imgR * 2;
          let sw = diam, sh = diam;
          if (ar > 1) { sw = diam * ar; } else { sh = diam / ar; }
          ctx.drawImage(img, cx - sw / 2, cx - sh / 2, sw, sh);
          ctx.restore();

          // 3. White ring border between glow and image
          ctx.strokeStyle = 'rgba(255,255,255,0.60)';
          ctx.lineWidth = size * 0.04;
          ctx.beginPath();
          ctx.arc(cx, cx, imgR, 0, Math.PI * 2);
          ctx.stroke();

          if (sprite && sprite.material) {
            // Verify canvas is not origin-tainted before uploading to WebGL.
            // A tainted canvas causes gl.texImage2D to silently fail, leaving an
            // invisible (all-zero) texture. Keep the placeholder if tainted.
            try { ctx.getImageData(0, 0, 1, 1); } catch(taintErr) { return; }
            const tex = new THREE.CanvasTexture(c);
            sprite.material.map = tex;
            sprite.material.needsUpdate = true;
          }
        } catch(e) { /* canvas draw error ‚Äî keep placeholder glow */ }
      };
      img.onerror = () => {}; // keep placeholder on error
      img.src = imgUrl;
    }

    let _dbgEvents = []; // ring buffer of events for HUD display
    function _dbgLog(msg) {
      const t = (performance.now()/1000).toFixed(1);
      _dbgEvents.push(t + ' ' + msg);
      if (_dbgEvents.length > 12) _dbgEvents.shift();
      console.warn('[DBG] ' + t + ' ' + msg);
    }

    function clearOrbitingPosts() {
      _dbgLog('clearOrbitingPosts had=' + (orbitingPosts ? orbitingPosts.children.length : 'null') + ' host=' + orbitHostId);
      if (orbitingPosts) {
        // orbitingPosts is now a THREE.Group of sprites
        orbitingPosts.children.slice().forEach(s => {
          if (s.material) {
            if (s.material.map) s.material.map.dispose(); // dispose CanvasTexture to free GPU memory
            s.material.dispose();
          }
          orbitingPosts.remove(s);
        });
        scene.remove(orbitingPosts);
        orbitingPosts = null;
      }
      orbitData = [];
      orbitHostId = null;
      selectedPlanetIndex = -1;
    }

    function spawnOrbitingPosts(userId, postCount, postCommentCounts, postIds, postDates, postImages) {
      _dbgLog('spawnOrbitingPosts userId=' + userId + ' n=' + postCount);
      clearOrbitingPosts();
      if (!points || postCount === 0) return;

      const count = Math.min(postCount, 100);
      orbitHostId = userId;

      // ‚îÄ‚îÄ Compute max safe orbit radius (half distance to nearest neighbour) ‚îÄ‚îÄ
      // This prevents planets from drifting closer to a different star than the host.
      let maxSafeRadius = 2.5; // default fallback (world units)
      const hostIndex = memberIndexMap.get(userId);
      if (hostIndex !== undefined && points.geometry) {
        const posArr = points.geometry.attributes.position.array;
        const hx = posArr[hostIndex * 3];
        const hy = posArr[hostIndex * 3 + 1];
        const hz = posArr[hostIndex * 3 + 2];
        let nearestDist = Infinity;
        const total = points.geometry.attributes.position.count;
        // Sample up to 2000 stars to find nearest ‚Äî avoid O(N¬≤) on large datasets
        const step = Math.max(1, Math.floor(total / 2000));
        for (let j = 0; j < total; j += step) {
          if (j === hostIndex) continue;
          const dx = posArr[j * 3] - hx;
          const dy = posArr[j * 3 + 1] - hy;
          const dz = posArr[j * 3 + 2] - hz;
          const d = Math.sqrt(dx*dx + dy*dy + dz*dz);
          if (d < nearestDist) nearestDist = d;
        }
        if (nearestDist < Infinity) {
          maxSafeRadius = nearestDist * 0.55; // stay within 55% of way to nearest star (planets further out)
        }
      }
      // Cap at 2.8 world units ‚Äî allows larger orbits, planets further from stars
      maxSafeRadius = Math.min(maxSafeRadius, 2.8);

      // ‚îÄ‚îÄ Fixed world-space planet size cap ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Planet sizes are fixed in world space so they look correct at any zoom level.
      // Basing size on star's data-driven `size` attribute (0‚Äì1 from activity/engagement)
      // rather than camera-distance-dependent LOD math, which caused planets spawned
      // from far away to be tiny when zoomed in (and vice versa).
      // Hard cap: 0.18 world units diameter ‚Äî big enough to see, small enough to orbit neatly.
      const starSizeAttr = (hostIndex !== undefined && points.geometry)
        ? (points.geometry.attributes.size.array[hostIndex] || 1)
        : 1;
      // Scale: star size attribute typically 1‚Äì20; map to 0.25‚Äì0.55 world units planet max.
      // Planets are fixed world-space size so they look correct at any zoom level.
      const maxPlanetSize = Math.min(0.25 + starSizeAttr * 0.015, 0.55);
      // Also expose starWorldRadius as a fixed estimate for orbit gap calculations
      const starWorldRadius = maxPlanetSize * 0.8; // rough host star radius estimate

      // ‚îÄ‚îÄ Pre-compute planet sizes and non-overlapping orbit radii ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Planet sprites are billboards ‚Äî their world-space "radius" is wSize/2.
      // To prevent planet-planet overlap: consecutive orbit shells must be at
      // least (wSize_a/2 + wSize_b/2) apart (sum of radii).
      // To prevent planet-star overlap: innermost orbit must be > wSize/2 away
      // from host (which sits at r=0 in orbit space).
      // To prevent planet reaching other stars: orbit + wSize/2 < maxSafeRadius.
      const planetSizes = [];
      for (let i = 0; i < count; i++) {
        const cc = (postCommentCounts && postCommentCounts[i]) || 0;
        // Base size 0.18 world units; grows with comment count up to maxPlanetSize cap
        const rawSize = 0.18 + Math.log(cc + 1) * 0.04;
        planetSizes.push(Math.min(rawSize, maxPlanetSize));
      }

      // Build orbit radii greedily: start from innermost safe position,
      // step outward by enough to clear the previous planet and the current one.
      const orbitRadii = [];
      const HOST_STAR_R = starWorldRadius; // use actual star world radius
      let r = HOST_STAR_R + planetSizes[0] / 2 + 0.15; // first orbit clears star with more padding
      for (let i = 0; i < count; i++) {
        const ps = planetSizes[i];
        // Ensure this planet clears the previous planet
        if (i > 0) {
          const prevEdge = orbitRadii[i - 1] + planetSizes[i - 1] / 2;
          r = Math.max(r, prevEdge + ps / 2 + 0.04);
        }
        // Cap: planet outer edge must not exceed safe boundary
        const rCapped = Math.min(r, maxSafeRadius - ps / 2);
        orbitRadii.push(rCapped);
        r = rCapped + ps / 2; // advance for next iteration
      }
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      // Group holds all planet sprites so we can move them together
      orbitingPosts = new THREE.Group();
      orbitingPosts.frustumCulled = false; // never cull the group regardless of camera distance
      orbitingPosts.renderOrder = 10; // render after beams/stars so planets always appear on top
      scene.add(orbitingPosts);

      const CANVAS_SIZE = 256;
      const GOLDEN = Math.PI * (3 - Math.sqrt(5));

      // Collect deferred image loads ‚Äî fired after a staggered delay so the
      // profile picture request (fired by flashPoint before this runs) wins
      // the browser's HTTP connection pool.
      const deferredImageLoads = [];

      for (let i = 0; i < count; i++) {
        const hue   = 30 + (i * 37) % 60; // warm orange-amber palette per planet
        const wSize = planetSizes[i];

        // Build placeholder canvas texture (instant, no network)
        const canvas  = _makePlanetCanvas(CANVAS_SIZE, hue);
        const texture = new THREE.CanvasTexture(canvas);

        const mat = new THREE.SpriteMaterial({
          map:         texture,
          transparent: true,
          depthWrite:  false,
          depthTest:   false, // always draw planets ‚Äî prevents them vanishing behind/inside beam geometry
          blending:    THREE.NormalBlending,
          opacity:     0.0, // start invisible ‚Äî entrance animation brings it in
        });
        const sprite = new THREE.Sprite(mat);
        sprite.renderOrder = 10; // matches group renderOrder ‚Äî render after beams and stars
        sprite.scale.set(wSize, wSize, 1);
        sprite.frustumCulled = false; // never cull ‚Äî planets are always near the selected star
        // _spawnTime staggered so planets fade in one after another
        const spawnDelay = i * 60; // ms ‚Äî each planet appears 60ms after the previous
        sprite.userData = { index: i, postId: postIds ? postIds[i] : null, _spawnTime: performance.now() + spawnDelay };
        orbitingPosts.add(sprite);

        // Queue image load ‚Äî staggered so profile pic loads first
        const imgUrl = postImages && postImages[i];
        if (imgUrl) {
          deferredImageLoads.push({ imgUrl, hue, sprite });
        }

        // Orbit params ‚Äî non-overlapping radii, slow speed
        const t = count > 1 ? i / (count - 1) : 0;
        const radius = orbitRadii[i];
        orbitData.push({
          angle:    i * GOLDEN,
          speed:    0.04 - t * 0.015,
          radius,
          tiltX:    (i * 0.9) % Math.PI,
          tiltZ:    (i * 1.4) % Math.PI,
          postId:   postIds   ? postIds[i]   : null,
          createdAt: postDates ? postDates[i] : null,
        });
      }

      // Planet image batches: start after profile picture has had time to load (prioritize profile pic).
      const BATCH_SIZE = 4;
      const PLANET_IMAGE_DELAY_MS = 450;
      function _runImageBatch(startIdx) {
        if (startIdx >= deferredImageLoads.length) return;
        const batch = deferredImageLoads.slice(startIdx, startIdx + BATCH_SIZE);
        let remaining = batch.length;
        const onDone = () => { remaining--; if (remaining === 0) _runImageBatch(startIdx + BATCH_SIZE); };
        batch.forEach(({ imgUrl, hue, sprite }) => {
          // Helper: given a loaded Image, draw it onto a canvas sprite
          const drawToSprite = (img, objectUrl) => {
            try {
              const c = document.createElement('canvas');
              c.width = c.height = CANVAS_SIZE;
              const ctx = c.getContext('2d');
              const cx = CANVAS_SIZE / 2;
              const grd = ctx.createRadialGradient(cx, cx, cx * 0.1, cx, cx, cx);
              grd.addColorStop(0,    `hsla(${hue},60%,30%,0.3)`);
              grd.addColorStop(0.55, `hsla(${hue},70%,40%,0.5)`);
              grd.addColorStop(0.7,  `hsla(${hue},85%,65%,0.9)`);
              grd.addColorStop(1.0,  `hsla(${hue},70%,30%,0.0)`);
              ctx.fillStyle = grd;
              ctx.beginPath();
              ctx.arc(cx, cx, cx, 0, Math.PI * 2);
              ctx.fill();
              ctx.save();
              const imgR = cx * (2 / 3);
              ctx.beginPath();
              ctx.arc(cx, cx, imgR, 0, Math.PI * 2);
              ctx.clip();
              const ar = img.width / img.height;
              const diam = imgR * 2;
              let sw = diam, sh = diam;
              if (ar > 1) { sw = diam * ar; } else { sh = diam / ar; }
              ctx.drawImage(img, cx - sw / 2, cx - sh / 2, sw, sh);
              ctx.restore();
              ctx.strokeStyle = 'rgba(255,255,255,0.60)';
              ctx.lineWidth = CANVAS_SIZE * 0.04;
              ctx.beginPath();
              ctx.arc(cx, cx, imgR, 0, Math.PI * 2);
              ctx.stroke();
              if (sprite && sprite.material) {
                const tex = new THREE.CanvasTexture(c);
                tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                sprite.material.map = tex;
                sprite.material.needsUpdate = true;
              }
            } catch(e) { /* canvas draw error ‚Äî keep placeholder */ }
            if (objectUrl) URL.revokeObjectURL(objectUrl);
            onDone();
          };

          // Fetch via blob to force image MIME type ‚Äî handles wrong extensions (e.g. _image.txt)
          fetch(imgUrl, { mode: 'cors' })
            .then(r => r.ok ? r.blob() : Promise.reject(r.status))
            .then(blob => {
              const img = new Image();
              function tryType(mime) {
                const objectUrl = URL.createObjectURL(new Blob([blob], { type: mime }));
                img.onload = () => drawToSprite(img, objectUrl);
                img.onerror = () => {
                  URL.revokeObjectURL(objectUrl);
                  if (mime === 'image/jpeg') tryType('image/png');
                  else onDone();
                };
                img.src = objectUrl;
              }
              tryType('image/jpeg');
            })
            .catch(() => {
              const img = new Image();
              img.crossOrigin = 'anonymous';
              img.onload = () => drawToSprite(img, null);
              img.onerror = () => onDone();
              img.src = imgUrl;
            });
        });
      }
      setTimeout(() => _runImageBatch(0), PLANET_IMAGE_DELAY_MS);
    }

    let _loadingPostsForUser = null; // guard against concurrent fetches for same user

    async function loadUserPosts(userId) {
      _dbgLog('loadUserPosts userId=' + userId + ' host=' + orbitHostId + ' loadingFor=' + _loadingPostsForUser);
      // If planets are already showing for this user, don't re-spawn them
      if (orbitHostId === userId && orbitingPosts && orbitingPosts.children.length > 0) { _dbgLog('loadUserPosts: GUARD-already-showing'); return; }
      // Prevent duplicate concurrent fetches for same user
      if (_loadingPostsForUser === userId) { _dbgLog('loadUserPosts: GUARD-already-loading'); return; }
      _loadingPostsForUser = userId;

      const postsGrid = document.getElementById('posts-grid');

      // Show loading state
      postsGrid.innerHTML = '<div class="posts-loading">Loading posts...</div>';

      try {
        // Fetch user's posts from Back4App.
        // Try Pointer syntax first (standard for Parse Pointer fields),
        // then fall back to plain string if needed (some setups accept both).
        const POST_HEADERS = {
          'X-Parse-Application-Id': 'Wuo5quzr8f2vZDeSSskftVcDKPUpm16VHdDLm3by',
          'X-Parse-REST-API-Key': 'rNXb9qIR6wrZ3n81OG33HVQkpPsXANUatiOE5HSq'
        };
        const POST_QUERY_BASE = {
          order: '-createdAt',
          limit: '100',
          keys: 'objectId,content,image,createdAt,commentCount'
        };

        // Primary: Pointer-format query
        const params = new URLSearchParams({
          ...POST_QUERY_BASE,
          where: JSON.stringify({
            creator: { __type: 'Pointer', className: '_User', objectId: userId }
          }),
        });

        let response = await fetch(`https://parseapi.back4app.com/classes/post?${params}`, {
          method: 'GET', headers: POST_HEADERS
        });

        let data = null;
        if (response.ok) {
          data = await response.json();
        }

        // Fallback: plain-string creator query (works on some Back4App configurations)
        if (!data || !data.results || data.results.length === 0) {
          const fallbackParams = new URLSearchParams({
            ...POST_QUERY_BASE,
            where: JSON.stringify({ creator: userId }),
          });
          const fallbackResp = await fetch(`https://parseapi.back4app.com/classes/post?${fallbackParams}`, {
            method: 'GET', headers: POST_HEADERS
          });
          if (fallbackResp.ok) data = await fallbackResp.json();
        }

        if (!data || !data.results) {
          console.error('Post loading failed for user', userId);
          throw new Error('Failed to load posts');
        }

        if (!data.results || data.results.length === 0) {
          postsGrid.innerHTML = '<div class="posts-loading">No posts yet</div>';
          return;
        }

        // Spawn orbiting planet for each post; pass per-post comment counts, ids, dates, images
        const postCommentCounts = data.results.map(p => p.commentCount || 0);
        const postIds   = data.results.map(p => p.objectId);
        const postDates = data.results.map(p => p.createdAt || null);
        const postImages = data.results.map(p => {
          if (typeof p.image === 'string' && p.image) return p.image;
          if (p.image && typeof p.image === 'object' && p.image.url) return p.image.url;
          return null;
        });
        spawnOrbitingPosts(userId, data.results.length, postCommentCounts, postIds, postDates, postImages);

        // Render posts grid (using correct field names: content, image)
        postsGrid.innerHTML = data.results.map((post, idx) => {
          // Handle image field (can be string URL or Parse File object)
          let mediaUrl = null;
          if (typeof post.image === 'string') {
            mediaUrl = post.image;
          } else if (post.image && typeof post.image === 'object' && post.image.url) {
            mediaUrl = post.image.url;
          }

          const hasMedia = mediaUrl && mediaUrl.length > 0;
          const text = post.content || '';

          if (hasMedia) {
            const safeText = text.slice(0, 100).replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            return `
              <div class="post-item loading" data-post-id="${post.objectId}" data-fallback-text="${safeText}" onclick="expandPost('${post.objectId}', '${userId}')">
                <img src="${mediaUrl}" data-src="${mediaUrl}" crossorigin="anonymous" alt="Post" onload="this.classList.add('loaded'); this.parentElement.classList.remove('loading');" onerror="_imgBlobFallback(this)" />
              </div>
            `;
          } else {
            return `
              <div class="post-item" data-post-id="${post.objectId}" onclick="expandPost('${post.objectId}', '${userId}')">
                <div class="post-text">${text}</div>
              </div>
            `;
          }
        }).join('');

      } catch (error) {
        console.error('Error loading posts:', error);
        postsGrid.innerHTML = '<div class="posts-loading">Failed to load posts</div>';
      } finally {
        if (_loadingPostsForUser === userId) _loadingPostsForUser = null;
      }
    }

    // Expand post view
    window.expandPost = async (postId, userId) => {
      const expandedView = document.getElementById('post-expanded');
      const imageEl = document.getElementById('post-expanded-image');
      const textEl = document.getElementById('post-expanded-text');
      const metaEl = document.getElementById('post-expanded-meta');

      // Show expanded view with animation
      expandedView.classList.add('visible');
      expandedView.scrollTop = 0;

      // Fetch full post data
      try {
        const params = new URLSearchParams({
          where: JSON.stringify({ objectId: postId }),
          keys: 'objectId,content,image,createdAt,commentCount,creator'
        });

        const response = await fetch(`https://parseapi.back4app.com/classes/post?${params}`, {
          method: 'GET',
          headers: {
            'X-Parse-Application-Id': 'Wuo5quzr8f2vZDeSSskftVcDKPUpm16VHdDLm3by',
            'X-Parse-REST-API-Key': 'rNXb9qIR6wrZ3n81OG33HVQkpPsXANUatiOE5HSq'
          }
        });

        if (!response.ok) {
          throw new Error('Failed to load post');
        }

        const data = await response.json();
        const post = data.results[0];

        if (!post) {
          throw new Error('Post not found');
        }

        // Display image if available
        let mediaUrl = null;
        if (typeof post.image === 'string') {
          mediaUrl = post.image;
        } else if (post.image && typeof post.image === 'object' && post.image.url) {
          mediaUrl = post.image.url;
        }

        if (mediaUrl) {
          fetch(mediaUrl, { mode: 'cors' })
            .then(r => r.ok ? r.blob() : Promise.reject(r.status))
            .then(blob => {
              function tryType(mime) {
                const objectUrl = URL.createObjectURL(new Blob([blob], { type: mime }));
                const prev = imageEl._blobUrl;
                if (prev) URL.revokeObjectURL(prev);
                imageEl._blobUrl = objectUrl;
                imageEl.onerror = () => {
                  URL.revokeObjectURL(objectUrl);
                  if (mime === 'image/jpeg') tryType('image/png');
                  else imageEl.src = mediaUrl;
                };
                imageEl.src = objectUrl;
              }
              tryType('image/jpeg');
            })
            .catch(() => { imageEl.src = mediaUrl; });
          imageEl.style.display = 'block';
        } else {
          imageEl.style.display = 'none';
        }

        // Display text content
        textEl.textContent = post.content || '';

        // Display metadata
        const date = new Date(post.createdAt);
        const dateStr = date.toLocaleDateString('en-US', {
          month: 'long',
          day: 'numeric',
          year: 'numeric'
        });
        metaEl.innerHTML = `
          <div>${dateStr}</div>
          <div>${post.commentCount || 0} comments</div>
        `;

        // Load comments
        await loadPostComments(postId);

      } catch (error) {
        console.error('Error loading post:', error);
        textEl.textContent = 'Failed to load post';
      }
    };

    // Load comments for a post
    async function loadPostComments(postId) {
      const commentsList = document.getElementById('post-comments-list');
      const commentCount = document.getElementById('comment-count');

      commentsList.innerHTML = '<div class="comments-loading">Loading comments...</div>';

      try {
        // Fetch comments with include=user to expand the user Pointer inline.
        // 'username' is also denormalized on the comment itself as a fallback.
        // 'post' is a plain string field (not a Pointer) so where clause uses raw string.
        const params = new URLSearchParams({
          where: JSON.stringify({ post: postId }),
          order: '-createdAt',
          limit: '100',
          keys: 'objectId,content,createdAt,username,user,user.username,user.proPic',
          include: 'user'
        });

        const response = await fetch(`https://parseapi.back4app.com/classes/comment?${params}`, {
          method: 'GET',
          headers: {
            'X-Parse-Application-Id': 'Wuo5quzr8f2vZDeSSskftVcDKPUpm16VHdDLm3by',
            'X-Parse-REST-API-Key': 'rNXb9qIR6wrZ3n81OG33HVQkpPsXANUatiOE5HSq'
          }
        });

        if (!response.ok) {
          throw new Error('Failed to load comments');
        }

        const data = await response.json();

        if (data.results.length === 0) {
          commentsList.innerHTML = '<div class="comments-loading">No comments yet</div>';
          commentCount.textContent = '';
          return;
        }

        commentCount.textContent = `(${data.results.length})`;

        // Render ‚Äî user is expanded inline; fall back to denormalized username on comment
        commentsList.innerHTML = data.results.map(comment => {
          const userObj = (comment.user && comment.user.__type !== 'Pointer') ? comment.user : {};
          const username = userObj.username || comment.username || 'Anonymous';
          const initials = getInitials(username);

          // Handle profile picture (string or Parse File object)
          let profilePicUrl = null;
          if (typeof userObj.proPic === 'string') {
            profilePicUrl = userObj.proPic;
          } else if (userObj.proPic && typeof userObj.proPic === 'object' && userObj.proPic.url) {
            profilePicUrl = userObj.proPic.url;
          }

          const date = new Date(comment.createdAt);
          const dateStr = date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
          });

          return `
            <div class="comment-item">
              <div class="comment-avatar">
                ${profilePicUrl
                  ? `<img src="${profilePicUrl}" crossorigin="anonymous" alt="${username}" />`
                  : initials
                }
              </div>
              <div class="comment-content">
                <div class="comment-header">
                  <span class="comment-username">@${username}</span>
                  <span class="comment-date">${dateStr}</span>
                </div>
                <div class="comment-text">${comment.content || ''}</div>
              </div>
            </div>
          `;
        }).join('');

      } catch (error) {
        console.error('Error loading comments:', error);
        commentsList.innerHTML = '<div class="comments-loading">Failed to load comments</div>';
      }
    }

    // Close expanded post view
    window.closeExpandedPost = () => {
      const expandedView = document.getElementById('post-expanded');
      expandedView.classList.remove('visible');
    };

    window.showSearchDropdown = () => {
      // Trigger search when input is focused
      const searchInput = document.querySelector('#search input');
      const event = { target: searchInput, key: '' };
      searchMember(event);
    };

    // Close dropdown when clicking outside
    document.addEventListener('click', (event) => {
      const searchContainer = document.getElementById('search');
      const dropdown = document.getElementById('search-dropdown');
      if (!searchContainer.contains(event.target)) {
        dropdown.classList.remove('visible');
      }
    });

    // Draw glowing connection lines from a user to everyone they've commented to
    function clearActiveConnectionLine() {
      if (activeConnectionLine) {
        // Remove all line layers (core + glow copies) ‚Äî each has its own geometry now
        activeConnectionLine.allSegments.forEach(ls => {
          scene.remove(ls);
          ls.geometry.dispose();  // each layer owns its geometry ‚Äî safe to dispose once
          ls.material.dispose();
        });
        activeConnectionLine = null;
      }
    }

    // Helper: fill a supporter card bg element with a profile image (or leave initials)
    function _setSupporterCardBgImage(bg, imageUrl, username) {
      bg.innerHTML = '';
      const initials = (username.replace(/^@/,'').slice(0,2)).toUpperCase();
      if (imageUrl) {
        const img = document.createElement('img');
        img.alt = username;
        bg.appendChild(img);
        loadImageWithBlobFallback(img, imageUrl,
          () => {},
          () => {
            img.remove();
            const initDiv = document.createElement('div');
            initDiv.className = 'supporter-card-initials';
            initDiv.textContent = initials;
            bg.appendChild(initDiv);
          },
          { forCanvas: false }
        );
      } else {
        const initDiv = document.createElement('div');
        initDiv.className = 'supporter-card-initials';
        initDiv.textContent = initials;
        bg.appendChild(initDiv);
      }
    }

    function renderSupporterCards(engagementCount, currentUserId) {
      const section = document.getElementById('supporters-section');
      if (!section) return;

      // Sort by engagement count descending, take top 3
      const sorted = Object.entries(engagementCount)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3);

      if (sorted.length === 0) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';
      const container = document.getElementById('supporter-cards-container');
      container.innerHTML = '';

      // Portrait playing card layout: cards fanned/spread left‚Üíright
      // Card 0 = top supporter (front, centre); 1 = left; 2 = right
      // Offsets: translateX centres cards within the container (cards are 100px wide)
      const containerWidth = container.offsetWidth || 220;
      const cardW = 100;
      // Fan spread: card 0 front, 1 tilted left behind, 2 tilted right behind
      const layouts = [
        { x: containerWidth / 2 - cardW / 2, rotate:  0, scale: 1.00, z: 3 }, // front/centre
        { x: containerWidth / 2 - cardW / 2 - 32, rotate: -8, scale: 0.93, z: 2 }, // left behind
        { x: containerWidth / 2 - cardW / 2 + 32, rotate:  8, scale: 0.93, z: 1 }, // right behind
      ];

      // Collect IDs that need a proPic fetch (no profilePicture in metadata yet)
      const needsFetch = [];

      sorted.forEach(([targetId, count], i) => {
        const meta = pointMetadata[memberIndexMap.get(targetId)];
        const username = meta ? (meta.username || meta.id) : targetId;
        const imageUrl = meta ? getProfilePictureUrl(meta.profilePicture) : null;

        const layout = layouts[i] || layouts[0];

        const card = document.createElement('div');
        card.className = 'supporter-card';
        card.style.zIndex = layout.z;
        card.style.transform = `translateX(${layout.x}px) translateX(-50%) rotate(${layout.rotate}deg) scale(${layout.scale})`;
        card.style.left = '0';
        card.onclick = () => {
          const idx = memberIndexMap.get(targetId);
          if (idx !== undefined) flashPoint(idx);
        };

        // Background layer ‚Äî profile image fills the card
        const bg = document.createElement('div');
        bg.className = 'supporter-card-bg';
        _setSupporterCardBgImage(bg, imageUrl, username);

        // If no image yet, queue a lazy fetch for this user's proPic
        if (!imageUrl) {
          needsFetch.push({ targetId, username, bg });
        }

        // Gradient overlay for readability
        const overlay = document.createElement('div');
        overlay.className = 'supporter-card-overlay';

        // Username label at bottom
        const label = document.createElement('div');
        label.className = 'supporter-card-label';
        label.innerHTML = `
          <span class="supporter-card-name">@${username}</span>
          <span class="supporter-card-count">${count}√ó</span>
        `;

        card.appendChild(bg);
        card.appendChild(overlay);
        card.appendChild(label);
        container.appendChild(card);
      });

      // Lazy-fetch proPic for any supporter whose metadata lacks a profile picture.
      // Batch all missing IDs into one request.
      if (needsFetch.length > 0) {
        const missingIds = needsFetch.map(e => e.targetId);
        const params = new URLSearchParams({
          where: JSON.stringify({ objectId: { $in: missingIds } }),
          keys: 'objectId,username,proPic,profilePicture',
          limit: String(missingIds.length),
        });
        fetch(`https://parseapi.back4app.com/classes/_User?${params}`, {
          headers: {
            'X-Parse-Application-Id': B4A_APP_ID,
            'X-Parse-REST-API-Key': 'rNXb9qIR6wrZ3n81OG33HVQkpPsXANUatiOE5HSq',
          }
        })
        .then(r => r.json())
        .then(data => {
          if (!data.results) return;
          const picMap = {};
          data.results.forEach(u => {
            const url = getProfilePictureUrl(u.proPic || u.profilePicture);
            if (url) picMap[u.objectId] = url;
          });
          // Update metadata + swap card bg images
          needsFetch.forEach(({ targetId, username, bg }) => {
            const url = picMap[targetId];
            if (!url) return;
            // Cache it in pointMetadata so future renders don't need to re-fetch
            const idx = memberIndexMap.get(targetId);
            if (idx !== undefined && pointMetadata[idx]) {
              pointMetadata[idx].profilePicture = url;
            }
            // Swap initials for real image ‚Äî only if this card bg is still in the DOM
            if (bg.isConnected) {
              _setSupporterCardBgImage(bg, url, username);
            }
          });
        })
        .catch(() => { /* silently ignore ‚Äî initials remain */ });
      }
    }

    async function drawConnectionLines(userId) {
      if (!points || !points.geometry || !points.geometry.attributes.position) return;

      const sourceIndex = memberIndexMap.get(userId);
      if (sourceIndex === undefined) return;

      // Snapshot the selected member index at call time ‚Äî used to detect stale results
      // after an async fetch that outlasts this selection (user clicked a different star).
      const snapshotSelectedIndex = selectedMemberIndex;

      // Clear previous line immediately (replace, not accumulate)
      clearActiveConnectionLine();

      const HEADERS = {
        'X-Parse-Application-Id': 'Wuo5quzr8f2vZDeSSskftVcDKPUpm16VHdDLm3by',
        'X-Parse-REST-API-Key': 'rNXb9qIR6wrZ3n81OG33HVQkpPsXANUatiOE5HSq'
      };

      try {
        // ‚îÄ‚îÄ Paginate comment fetch: cursor-based (createdAt) to avoid Back4App skip limits ‚îÄ‚îÄ
        // (skip is often capped at 1000; cursor pagination works for any comment count)
        const PAGE_SIZE = 500;
        const MAX_COMMENTS = 15000; // cap for performance; cursor pagination avoids skip limit
        let allComments = [];
        let lastCreatedAt = null; // cursor for next page
        let keepFetching = true;
        let commentCreatorQuery = { creator: { __type: 'Pointer', className: '_User', objectId: userId } };
        let usedPointerQuery = true;

        while (keepFetching) {
          const where = lastCreatedAt
            ? { $and: [commentCreatorQuery, { createdAt: { $gt: { __type: 'Date', iso: lastCreatedAt } } }] }
            : commentCreatorQuery;
          const p = new URLSearchParams({
            where: JSON.stringify(where),
            limit: String(PAGE_SIZE),
            keys: 'creator,post,createdAt',
            order: 'createdAt',
          });
          const resp = await fetch(`https://parseapi.back4app.com/classes/comment?${p}`, { method: 'GET', headers: HEADERS });
          if (!resp.ok) break;
          const data = await resp.json();
          if ((!data.results || data.results.length === 0) && usedPointerQuery && !lastCreatedAt) {
            commentCreatorQuery = { creator: userId };
            usedPointerQuery = false;
            continue;
          }
          if (!data.results || data.results.length === 0) break;
          allComments = allComments.concat(data.results);
          const last = data.results[data.results.length - 1];
          lastCreatedAt = (last && last.createdAt && last.createdAt.iso) ? last.createdAt.iso : (last && last.createdAt);
          if (!lastCreatedAt || data.results.length < PAGE_SIZE) keepFetching = false;
          if (allComments.length >= MAX_COMMENTS) keepFetching = false;
        }
        if (allComments.length === 0) return;

        // ‚îÄ‚îÄ Extract post IDs ‚Äî Back4App returns `post` as a Parse Pointer object ‚îÄ‚îÄ
        // e.g. { __type: "Pointer", className: "post", objectId: "abc123" }
        // Must unwrap .objectId; plain strings are also handled for safety.
        function parseId(val) {
          if (!val) return null;
          if (typeof val === 'string') return val;
          if (typeof val === 'object' && val.objectId) return val.objectId;
          return null;
        }

        const postIdSet = new Set(allComments.map(c => parseId(c.post)).filter(Boolean));
        if (postIdSet.size === 0) return;
        const allPostIds = [...postIdSet];

        // ‚îÄ‚îÄ Fetch posts in small chunks to avoid URL length limits (414) ‚îÄ‚îÄ
        // 500 IDs in $in can exceed ~2k URL limit; 100 keeps URLs safe and still batches well
        const POST_CHUNK = 100;
        const postCreatorMap = {};
        for (let pi = 0; pi < allPostIds.length; pi += POST_CHUNK) {
          const chunk = allPostIds.slice(pi, pi + POST_CHUNK);
          const pp = new URLSearchParams({
            where: JSON.stringify({ objectId: { $in: chunk } }),
            keys: 'objectId,creator',
            limit: String(chunk.length),
          });
          const resp = await fetch(`https://parseapi.back4app.com/classes/post?${pp}`, { method: 'GET', headers: HEADERS });
          if (!resp.ok) continue;
          const data = await resp.json();
          (data.results || []).forEach(p => {
            const creatorId = parseId(p.creator);
            if (p.objectId && creatorId) postCreatorMap[p.objectId] = creatorId;
          });
        }

        // ‚îÄ‚îÄ Count engagement per target creator ‚îÄ‚îÄ
        const engagementCount = {};
        allComments.forEach(c => {
          const postId = parseId(c.post);
          const creatorId = postId ? postCreatorMap[postId] : null;
          if (creatorId && creatorId !== userId) {
            engagementCount[creatorId] = (engagementCount[creatorId] || 0) + 1;
          }
        });

        // ‚îÄ‚îÄ Collect targets in scene ‚îÄ‚îÄ
        const targetIds = Object.keys(engagementCount);
        // Pair targetIndices with engagement weights, filter to those in scene
        const targetPairs = targetIds
          .map(id => ({ id, idx: memberIndexMap.get(id), count: engagementCount[id] }))
          .filter(p => p.idx !== undefined);

        if (targetPairs.length === 0) return;

        const targetIndices = targetPairs.map(p => p.idx);
        const targetCounts  = targetPairs.map(p => p.count);
        const maxCount = Math.max(...targetCounts, 1);

        // ‚îÄ‚îÄ Render supporter cards ‚îÄ‚îÄ
        renderSupporterCards(engagementCount, userId);

        // ‚îÄ‚îÄ Build per-layer geometries (each layer gets its own BufferGeometry) ‚îÄ‚îÄ
        // Using separate geometries per layer avoids THREE.js shared-geometry bugs:
        // when multiple LineSegments share one geometry, the WebGL VAO/VBO state
        // can be inconsistently managed, and clearActiveConnectionLine's dispose()
        // would try to free the same GPU buffer 3 times. Each layer owns its copy.
        const vertBuf = new Float32Array(targetPairs.length * 6);

        // Per-segment strength attribute (one value per segment = one per vertex pair)
        // We duplicate it per vertex so the shader gets it at each endpoint
        const strengthArr = new Float32Array(targetPairs.length * 2);
        targetPairs.forEach(({ count }, i) => {
          const s = Math.log(1 + count) / Math.log(1 + maxCount); // 0‚Äì1 log-normalised
          strengthArr[i * 2]     = s;
          strengthArr[i * 2 + 1] = s;
        });

        // Factory: make a fresh BufferGeometry for one beam layer.
        // position data is shared via the same Float32Array (written by updateConnectionLinePositions)
        // so all layers always render the same segment endpoints.
        function _makeLayerGeo() {
          const geo = new THREE.BufferGeometry();
          const posAttr = new THREE.BufferAttribute(vertBuf, 3);
          posAttr.setUsage(THREE.DynamicDrawUsage);
          geo.setAttribute('position', posAttr);
          geo.setAttribute('aStrength', new THREE.BufferAttribute(strengthArr.slice(), 1));
          return geo;
        }

        // Primary geometry reference ‚Äî used by updateConnectionLinePositions to write positions
        const lineGeo = _makeLayerGeo();

        // ‚îÄ‚îÄ Beam shader: pulsing + per-segment thickness via alpha & colour ‚îÄ‚îÄ
        const beamVert = `
          attribute float aStrength;
          varying float vLineDist;
          varying float vStrength;
          void main() {
            vLineDist = float(gl_VertexID) * 0.5;
            vStrength = aStrength;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `;

        // Three layers: outer glow, mid, sharp core ‚Äî thickness scales with engagement
        const beamLayers = [
          { baseAlpha: 0.12, colScale: 0.65 }, // wide soft glow
          { baseAlpha: 0.30, colScale: 0.82 }, // medium halo
          { baseAlpha: 0.90, colScale: 1.00 }, // bright core
        ];
        // Stale-result guard: if the user changed selection while we were fetching,
        // discard these beam results ‚Äî they're for a star the user is no longer viewing.
        if (selectedMemberIndex !== snapshotSelectedIndex) {
          _dbgLog('BEAMS-STALE discarding userId=' + userId);
          return;
        }

        const allSegments = [];
        let lineSegments = null;
        const beamStartTime = performance.now();

        beamLayers.forEach(({ baseAlpha, colScale }, layerIdx) => {
          const mat = new THREE.ShaderMaterial({
            uniforms: {
              time:      { value: 0 },
              fadeIn:    { value: 0 }, // 0‚Üí1 entrance fade over 600ms
              baseAlpha: { value: baseAlpha },
              colScale:  { value: colScale },
            },
            vertexShader: beamVert,
            fragmentShader: `
              uniform float time;
              uniform float fadeIn;
              uniform float baseAlpha;
              uniform float colScale;
              varying float vLineDist;
              varying float vStrength;
              void main() {
                float pulse = sin(vLineDist * 12.0 - time * 4.0) * 0.5 + 0.5;
                // Thicker = more opaque: strength boosts alpha 1√ó to 2.5√ó
                float thickMult = 1.0 + vStrength * 1.5;
                float alpha = (0.20 + pulse * 0.65) * baseAlpha * thickMult * fadeIn;
                vec3 col = mix(vec3(0.55, 0.35, 1.0), vec3(0.85, 0.7, 1.0), pulse) * colScale;
                // High-engagement beams shift towards brighter violet
                col = mix(col, vec3(0.90, 0.80, 1.0), vStrength * 0.4);
                gl_FragColor = vec4(col, alpha);
              }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            depthTest: false, // beams never occlude anything; disabling avoids depth state interaction with planet sprites
          });
          // First layer uses the primary lineGeo (updated by updateConnectionLinePositions);
          // subsequent layers get their own geometry copy so each layer has independent
          // WebGL VAO/VBO state ‚Äî avoids THREE.js shared-geometry rendering issues.
          const layerGeo = layerIdx === 0 ? lineGeo : _makeLayerGeo();
          const ls = new THREE.LineSegments(layerGeo, mat);
          scene.add(ls);
          allSegments.push(ls);
          if (layerIdx === beamLayers.length - 1) lineSegments = ls;
        });

        {
          const planetCount = orbitingPosts ? orbitingPosts.children.length : 0;
          let opacitySnapshot = '';
          if (orbitingPosts && planetCount > 0) {
            const s0 = orbitingPosts.children[0];
            opacitySnapshot = ' op0=' + s0.material.opacity.toFixed(2) + ' fv0=' + s0.userData._fullyVisible + ' inScene=' + scene.children.includes(orbitingPosts);
          }
          _dbgLog('BEAMS-ADDED segs=' + allSegments.length + ' planets=' + planetCount + opacitySnapshot);
        }

        activeConnectionLine = {
          lineSegments, allSegments, sourceIndex, targetIndices, targetIds,
          beamStartTime,
          lineGeo,  // primary geometry reference ‚Äî disposed once on clear
        };

        updateConnectionLinePositions();

      } catch (err) {
        console.warn('drawConnectionLines error:', err);
      }
    }

    // Called every frame in animate() to keep lines glued to moving stars
    function updateConnectionLinePositions() {
      if (!activeConnectionLine || !points) return;
      const { lineSegments, allSegments, sourceIndex, targetIndices, beamStartTime } = activeConnectionLine;
      const posArr = points.geometry.attributes.position.array;
      const buf = lineSegments.geometry.attributes.position.array;
      const sx = posArr[sourceIndex * 3];
      const sy = posArr[sourceIndex * 3 + 1];
      const sz = posArr[sourceIndex * 3 + 2];
      for (let i = 0; i < targetIndices.length; i++) {
        const ti = targetIndices[i];
        const o = i * 6;
        buf[o]     = sx; buf[o + 1] = sy; buf[o + 2] = sz;
        buf[o + 3] = posArr[ti * 3];
        buf[o + 4] = posArr[ti * 3 + 1];
        buf[o + 5] = posArr[ti * 3 + 2];
      }
      // Each layer has its own BufferGeometry but all share the same underlying Float32Array
      // (vertBuf). Mark all layers' position attributes as needing GPU upload so each
      // layer renders with the updated positions.
      allSegments.forEach(ls => {
        ls.geometry.attributes.position.needsUpdate = true;
      });
      // Entrance fade-in: 0‚Üí1 over 600ms
      const fadeIn = beamStartTime ? Math.min(1, (performance.now() - beamStartTime) / 600) : 1;
      const t = performance.now() / 1000;
      allSegments.forEach(ls => {
        if (ls.material.uniforms) {
          ls.material.uniforms.time.value = t;
          ls.material.uniforms.fadeIn.value = fadeIn;
        }
      });
    }

    // Kept for the clear-connections button; also clears active line
    window.clearConnectionLines = function clearConnectionLines() {
      clearActiveConnectionLine();
      connectionLines.clear(); // stub map ‚Äî always empty now
      const clearBtn = document.getElementById('clear-connections-btn');
      if (clearBtn) clearBtn.style.display = 'none';
    }

    function animate() {
      requestAnimationFrame(animate);

      // Update FPS
      frameCount++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
        document.getElementById('fps').textContent = fps;

        // Update memory if available
        if (performance.memory) {
          const mem = performance.memory.usedJSHeapSize / 1024 / 1024;
          document.getElementById('memory').textContent = mem.toFixed(1) + ' MB';
        }
      }

      // Update controls
      controls.update();

      // Auto-rotate if enabled
      if (rotating) {
        controls.autoRotate = true;
      } else {
        controls.autoRotate = false;
      }

      // Update shader time uniform
      if (points && points.material.uniforms) {
        points.material.uniforms.time.value = now / 1000;
      }

      // Animate orbiting post-planets (sprite group) around the selected member
      if (orbitingPosts && orbitData.length > 0 && orbitHostId && points) {
        const hostIndex = memberIndexMap.get(orbitHostId);
        if (hostIndex !== undefined) {
          const posAttr = points.geometry.attributes.position;
          const hx = posAttr.array[hostIndex * 3];
          const hy = posAttr.array[hostIndex * 3 + 1];
          const hz = posAttr.array[hostIndex * 3 + 2];

          const t = now / 1000;

          for (let i = 0; i < orbitData.length; i++) {
            const o = orbitData[i];
            const a = o.angle + t * o.speed;
            // Tilted orbit plane
            const cx = Math.cos(a) * o.radius;
            const cy = Math.sin(a) * o.radius;
            const rx = cx * Math.cos(o.tiltZ) - cy * Math.sin(o.tiltX) * Math.sin(o.tiltZ);
            const ry = cx * Math.sin(o.tiltZ) + cy * Math.cos(o.tiltX);
            const rz = cy * Math.sin(o.tiltX);

            const sprite = orbitingPosts.children[i];
            if (sprite) {
              sprite.position.set(hx + rx, hy + ry, hz + rz);

              // Entrance fade-in: ramp opacity 0 ‚Üí 0.92 over 500ms after _spawnTime
              if (!sprite.userData._fullyVisible) {
                const FADE_DURATION = 500; // ms
                const age = performance.now() - (sprite.userData._spawnTime || 0);
                if (age <= 0) {
                  sprite.material.opacity = 0;
                } else if (age < FADE_DURATION) {
                  sprite.material.opacity = (age / FADE_DURATION) * 0.92;
                } else {
                  sprite.material.opacity = 0.92;
                  sprite.userData._fullyVisible = true; // stop updating every frame
                }
              } else if (sprite.material.opacity < 0.1) {
                // Safety net: if somehow opacity dropped after becoming fully visible, restore it
                _dbgLog('OPACITY-RESTORE planet ' + i + ' was ' + sprite.material.opacity.toFixed(3));
                sprite.material.opacity = 0.92;
                sprite.material.needsUpdate = true;
              }
            }

          }
        }
      }

      // Update connection lines to follow moving stars
      updateConnectionLinePositions();

      // Reproject selected star to screen for floating label + update sprite position
      if (selectedMemberIndex !== null && points && selectedLabel) {
        const posArr = points.geometry.attributes.position.array;
        const wx = posArr[selectedMemberIndex * 3];
        const wy = posArr[selectedMemberIndex * 3 + 1];
        const wz = posArr[selectedMemberIndex * 3 + 2];

        // Project world ‚Üí NDC ‚Üí screen (reuse vector ‚Äî no per-frame allocation)
        _projectVec.set(wx, wy, wz);
        _projectVec.project(camera);
        const vec = _projectVec;
        const hw = window.innerWidth / 2;
        const hh = window.innerHeight / 2;
        const sx = Math.round(vec.x * hw + hw);
        const sy = Math.round(-vec.y * hh + hh);

        // Only show label when star is in front of camera
        if (vec.z < 1.0) {
          selectedLabel.style.display = 'block';
          selectedLabel.style.left = sx + 'px';
          selectedLabel.style.top = sy + 'px';
        } else {
          selectedLabel.style.display = 'none';
        }

        // Keep sprite glued to star world position
        if (selectedSprite && !selectedSprite._placeholder && !selectedSprite._disposed) {
          selectedSprite.position.set(wx, wy, wz);
        }
      }

      // Update draw calls
      document.getElementById('draws').textContent = renderer.info.render.calls;

      // Render
      renderer.render(scene, camera);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
      // Don't trigger if typing in search box
      if (event.target.tagName === 'INPUT') return;

      switch(event.key.toLowerCase()) {
        case 'r':
          toggleRotation();
          break;
        case 'h':
          resetCamera();
          break;
        case 'f':
          focusOnCluster();
          break;
        case 'a':
          toggleAdmin();
          break;
        case '/':
          document.querySelector('#search input').focus();
          event.preventDefault();
          break;
        case 'escape':
          closeDetail();
          document.getElementById('help').classList.remove('visible');
          document.getElementById('admin-sidebar').classList.remove('visible');
          break;
        case '?':
          toggleHelp();
          break;
      }
    }

    window.generatePoints = (count) => {
      generatePoints(count);
      // Update button states
      document.querySelectorAll('#controls button').forEach(btn => {
        btn.classList.remove('active');
        if (btn.textContent.includes(count.toLocaleString())) {
          btn.classList.add('active');
        }
      });
    };

    window.toggleRotation = () => {
      rotating = !rotating;
    };

    window.resetCamera = () => {
      // Position slightly to the side so the full time-column (Y axis) is visible
      camera.position.set(120, 0, 80);
      camera.lookAt(0, 0, 0);
      controls.target.set(0, 0, 0);
      controls.update();
    };

    window.focusOnCluster = () => {
      if (!points) return;

      // Pick a random point and zoom to it
      const positions = points.geometry.attributes.position.array;
      const randomIndex = Math.floor(Math.random() * (positions.length / 3)) * 3;

      const targetPos = new THREE.Vector3(
        positions[randomIndex],
        positions[randomIndex + 1],
        positions[randomIndex + 2]
      );

      // Smooth camera transition
      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();
      const endPos = targetPos.clone().add(new THREE.Vector3(15, 15, 15));
      const endTarget = targetPos;

      let t = 0;
      const animateZoom = () => {
        t += 0.05;
        if (t > 1) t = 1;

        camera.position.lerpVectors(startPos, endPos, t);
        controls.target.lerpVectors(startTarget, endTarget, t);
        controls.update();

        if (t < 1) requestAnimationFrame(animateZoom);
      };
      animateZoom();
    };

    window.toggleHelp = () => {
      const help = document.getElementById('help');
      help.classList.toggle('visible');
    };

    window.toggleAdmin = () => {
      const sidebar = document.getElementById('admin-sidebar');
      sidebar.classList.toggle('visible');
    };

    // Click outside to close admin sidebar
    function handleClickOutside(event) {
      const sidebar = document.getElementById('admin-sidebar');
      const toggleBtn = document.getElementById('admin-toggle');

      if (sidebar.classList.contains('visible')) {
        // Check if click is outside both sidebar and toggle button
        if (!sidebar.contains(event.target) && !toggleBtn.contains(event.target)) {
          sidebar.classList.remove('visible');
        }
      }
    }

    // Add event listener
    document.addEventListener('click', handleClickOutside);

    window.focusOnSelected = () => {
      if (selectedMemberIndex !== null) {
        flashPoint(selectedMemberIndex);
      }
    };

    // Job Management System
    function createJob(name, type) {
      const job = {
        id: jobIdCounter++,
        name,
        type,
        status: 'running',
        progress: 0,
        startTime: Date.now(),
        message: 'Initializing...',
      };
      jobs.push(job);
      renderJobs();
      return job;
    }

    function updateJob(jobId, updates) {
      const job = jobs.find(j => j.id === jobId);
      if (job) {
        Object.assign(job, updates);
        renderJobs();
      }
    }

    function renderJobs() {
      const container = document.getElementById('jobs-container');
      if (jobs.length === 0) {
        container.innerHTML = '<p style="color: #666; font-style: italic;">No background jobs running</p>';
        return;
      }

      container.innerHTML = jobs.map(job => `
        <div class="job-item">
          <div>
            <strong>${job.name}</strong>
            <span class="job-status ${job.status}">${job.status.toUpperCase()}</span>
          </div>
          <div style="font-size: 12px; color: #999; margin: 5px 0;">${job.message}</div>
          <div class="progress-bar">
            <div class="progress-fill" style="width: ${job.progress}%"></div>
          </div>
          <div style="font-size: 11px; color: #666; margin-top: 5px;">
            ${job.progress.toFixed(0)}% ‚Ä¢ ${((Date.now() - job.startTime) / 1000).toFixed(1)}s elapsed
          </div>
        </div>
      `).join('');
    }

    window.clearAllJobs = () => {
      jobs = jobs.filter(j => j.status === 'running');
      renderJobs();
    };

    window.resetJobState = () => {
      if (confirm('This will reset the job state and snapshot cache, starting from scratch. Continue?')) {
        localStorage.removeItem('universeJobState');
        localStorage.removeItem(SNAPSHOT_KEY);
        const el = document.getElementById('snapshot-status');
        if (el) el.textContent = '';
        loadedMemberIds.clear();
        memberIndexMap.clear();

        // Remove all points
        if (points) {
          scene.remove(points);
          points.geometry.dispose();
          points.material.dispose();
          points = null;
        }
        pointMetadata = [];

        // Reset stats
        document.getElementById('admin-total').textContent = '0';
        document.getElementById('admin-real').textContent = '0';
        document.getElementById('admin-synthetic').textContent = '0';
        document.getElementById('count').textContent = '0';

        alert('Job state reset. Click "Continue Loading Data" to start fresh.');
      }
    };

    // Real Data Loading Job
    // Helper function to get risk color
    function getRiskColor(risk) {
      if (risk < 0.33) {
        const t = risk * 3;
        return { r: 0, g: t, b: 1 };
      } else if (risk < 0.66) {
        const t = (risk - 0.33) * 3;
        return { r: t, g: 1, b: 1 - t };
      } else {
        const t = (risk - 0.66) * 3;
        return { r: 1, g: 1 - t, b: 0 };
      }
    }

    // Helper function to enrich point cloud data incrementally
    function enrichPointCloudData(state) {
      const newPositions = [];
      const newColors = [];
      const newSizes = [];
      const newActivities = [];
      const newVertexIndices = [];
      const newMetadata = [];

      let nextIndex = points ? points.geometry.attributes.position.count : 0;

      state.members.forEach((member, id) => {
        const existingIndex = memberIndexMap.get(id);

        if (existingIndex !== undefined) {
          // UPDATE existing member ‚Äî only refresh activity/color/size/metadata.
          // NEVER overwrite position: the snapshot laid out all ~35k members together,
          // so their positions are stable and correct. Incremental enrichment only has
          // a small batch (~2500 members), so re-running evolve() on that mini-state
          // produces positions that are completely different from the full-universe
          // layout. Overwriting would teleport stars (and their orbiting planets)
          // off-screen mid-session.
          const postCount = Array.from(state.posts.values()).filter(p => p.creator === id).length;
          const commentCount = Array.from(state.comments.values()).filter(c => c.fromMember === id).length;
          const activity = postCount + commentCount;
          const risk = Math.random(); // TODO: Use actual predictions

          // Update color/size/activity in-place ‚Äî leave position untouched
          const colors = points.geometry.attributes.color.array;
          const sizes = points.geometry.attributes.size.array;
          const activities = points.geometry.attributes.activity.array;

          const color = getRiskColor(risk);
          colors[existingIndex * 3] = color.r;
          colors[existingIndex * 3 + 1] = color.g;
          colors[existingIndex * 3 + 2] = color.b;

          sizes[existingIndex] = 2 + Math.log(commentCount + 1) * 0.8;
          activities[existingIndex] = Math.min(activity / 100, 1);

          // Update metadata ‚Äî preserve existing profilePicture and position
          // (member stubs created via posts/comments don't have proPic yet)
          const existingPic = pointMetadata[existingIndex]?.profilePicture || null;
          const existingPos = pointMetadata[existingIndex]?.position || { x: 0, y: 0, z: 0 };
          pointMetadata[existingIndex] = {
            id,
            username: member.username || 'Anonymous',
            profilePicture: member.proPic || existingPic,
            position: existingPos, // keep stable snapshot position
            risk: (risk * 100).toFixed(0),
            riskLevel: risk < 0.33 ? 'low' : risk < 0.66 ? 'medium' : 'high',
            activity,
            sobrietyDays: member.sobriety
              ? Math.floor((Date.now() - new Date(member.sobriety).getTime()) / 86400000)
              : 0,
            cluster: 'Real Data',
          };
        } else {
          // APPEND new member
          const pos = member.position || { x: 0, y: 0, z: 0 };
          newPositions.push(pos.x, pos.y, pos.z);

          const postCount = Array.from(state.posts.values()).filter(p => p.creator === id).length;
          const commentCount = Array.from(state.comments.values()).filter(c => c.fromMember === id).length;
          const activity = postCount + commentCount;
          const risk = Math.random(); // TODO: Use actual predictions

          const color = getRiskColor(risk);
          newColors.push(color.r, color.g, color.b);

          newSizes.push(2 + Math.log(commentCount + 1) * 0.8);
          newActivities.push(Math.min(activity / 100, 1));
          newVertexIndices.push(nextIndex);

          newMetadata.push({
            id,
            username: member.username || 'Anonymous',
            profilePicture: member.proPic || null,
            position: { x: pos.x, y: pos.y, z: pos.z },
            risk: (risk * 100).toFixed(0),
            riskLevel: risk < 0.33 ? 'low' : risk < 0.66 ? 'medium' : 'high',
            activity,
            sobrietyDays: member.sobriety
              ? Math.floor((Date.now() - new Date(member.sobriety).getTime()) / 86400000)
              : 0,
            cluster: 'Real Data',
          });

          memberIndexMap.set(id, nextIndex);
          loadedMemberIds.add(id);
          nextIndex++;
        }
      });

      // If there are new members, expand geometry
      if (newPositions.length > 0) {
        if (points && points.geometry) {
          // Expand existing geometry
          const oldPositions = points.geometry.attributes.position.array;
          const oldColors = points.geometry.attributes.color.array;
          const oldSizes = points.geometry.attributes.size.array;
          const oldActivities = points.geometry.attributes.activity.array;
          const oldVertexIndices = points.geometry.attributes.vertexIndex.array;

          const newPosArray = new Float32Array(oldPositions.length + newPositions.length);
          const newColArray = new Float32Array(oldColors.length + newColors.length);
          const newSizeArray = new Float32Array(oldSizes.length + newSizes.length);
          const newActArray = new Float32Array(oldActivities.length + newActivities.length);
          const newIdxArray = new Float32Array(oldVertexIndices.length + newVertexIndices.length);

          newPosArray.set(oldPositions);
          newPosArray.set(newPositions, oldPositions.length);

          newColArray.set(oldColors);
          newColArray.set(newColors, oldColors.length);

          newSizeArray.set(oldSizes);
          newSizeArray.set(newSizes, oldSizes.length);

          newActArray.set(oldActivities);
          newActArray.set(newActivities, oldActivities.length);

          newIdxArray.set(oldVertexIndices);
          newIdxArray.set(newVertexIndices, oldVertexIndices.length);

          // Update geometry
          points.geometry.setAttribute('position', new THREE.BufferAttribute(newPosArray, 3));
          points.geometry.setAttribute('color', new THREE.BufferAttribute(newColArray, 3));
          points.geometry.setAttribute('size', new THREE.BufferAttribute(newSizeArray, 1));
          points.geometry.setAttribute('activity', new THREE.BufferAttribute(newActArray, 1));
          points.geometry.setAttribute('vertexIndex', new THREE.BufferAttribute(newIdxArray, 1));

          // Append metadata
          pointMetadata.push(...newMetadata);
        } else {
          // Create new geometry (first load)
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(newPositions), 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(newColors), 3));
          geometry.setAttribute('size', new THREE.BufferAttribute(new Float32Array(newSizes), 1));
          geometry.setAttribute('activity', new THREE.BufferAttribute(new Float32Array(newActivities), 1));
          geometry.setAttribute('vertexIndex', new THREE.BufferAttribute(new Float32Array(newVertexIndices), 1));

          const material = new THREE.ShaderMaterial({
            vertexShader: starVertexShader,
            fragmentShader: starFragmentShader,
            uniforms: {
              time: { value: 0 },
              selectedIndex: { value: -1.0 }
            },
            transparent: true,
            depthWrite: false,
            blending: THREE.NormalBlending, // Changed from AdditiveBlending to prevent white ball effect
          });

          points = new THREE.Points(geometry, material);
          scene.add(points);

          pointMetadata = newMetadata;
        }

        // Mark attributes as needing update
        points.geometry.attributes.position.needsUpdate = true;
        points.geometry.attributes.color.needsUpdate = true;
        points.geometry.attributes.size.needsUpdate = true;
        points.geometry.attributes.activity.needsUpdate = true;
        points.geometry.attributes.vertexIndex.needsUpdate = true;
      } else {
        // No new members, just update existing color/size/activity (position unchanged)
        if (points && points.geometry) {
          points.geometry.attributes.color.needsUpdate = true;
          points.geometry.attributes.size.needsUpdate = true;
          points.geometry.attributes.activity.needsUpdate = true;
        }
      }

      // If URL has a user id, select that user (e.g. returning to a bookmarked link)
      if (points && pointMetadata.length > 0) applyUserFromUrl();
    }

    // ‚îÄ‚îÄ‚îÄ Universe Snapshot System ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Snapshots let the universe restore instantly on reload without re-fetching.
    // Each entry: { id, username, proPic, x, y, z, size, activity, sobrietyDays }
    // Stored under 'universeSnapshot' in localStorage (compact JSON, ~100B/member).
    // The skips counters travel with the snapshot so incremental loads pick up
    // exactly where we left off, only fetching members we don't have yet.

    const SNAPSHOT_KEY = 'universeSnapshot';
    const SNAPSHOT_VERSION = 4; // bumped ‚Äî invalidate old snapshot so profile pictures re-load from API

    function loadSnapshot() {
      try {
        const raw = localStorage.getItem(SNAPSHOT_KEY);
        if (!raw) return null;
        const snap = JSON.parse(raw);
        if (snap.version !== SNAPSHOT_VERSION) return null;
        return snap;
      } catch (e) {
        return null;
      }
    }

    function saveSnapshot(skips) {
      // Serialize the current point cloud into a compact member array.
      if (!pointMetadata || pointMetadata.length === 0) return;
      const geo = points && points.geometry;
      const posArr = geo ? geo.attributes.position.array : null;
      const sizeArr = geo ? geo.attributes.size.array : null;
      const actArr = geo ? geo.attributes.activity.array : null;

      const members = pointMetadata.map((m, i) => {
        const x = posArr ? posArr[i * 3]     : (m.position?.x ?? 0);
        const y = posArr ? posArr[i * 3 + 1] : (m.position?.y ?? 0);
        const z = posArr ? posArr[i * 3 + 2] : (m.position?.z ?? 0);
        return {
          id:            m.id,
          username:      m.username,
          proPic:        m.profilePicture || null,
          x, y, z,
          size:          sizeArr ? sizeArr[i] : 1,
          activity:      actArr  ? actArr[i]  : 0,
          sobrietyDays:  m.sobrietyDays || 0,
        };
      });

      const snap = {
        version:   SNAPSHOT_VERSION,
        timestamp: Date.now(),
        skips,
        members,
      };

      try {
        localStorage.setItem(SNAPSHOT_KEY, JSON.stringify(snap));
        updateSnapshotStatus(members.length, snap.timestamp);
      } catch (e) {
        // localStorage quota exceeded ‚Äî round-trip coordinates to 3 decimal places to shrink size.
        // NEVER strip proPic ‚Äî that causes profile images to go blank after restore.
        const compact = {
          ...snap,
          members: members.map(m => ({
            id: m.id,
            username: m.username,
            proPic: m.proPic || null,
            x: +m.x.toFixed(3), y: +m.y.toFixed(3), z: +m.z.toFixed(3),
            size: +m.size.toFixed(2),
            activity: +m.activity.toFixed(3),
            sobrietyDays: m.sobrietyDays || 0,
          }))
        };
        try {
          localStorage.setItem(SNAPSHOT_KEY, JSON.stringify(compact));
          updateSnapshotStatus(members.length, snap.timestamp, '(compact)');
        } catch (e2) {
          // Still too large ‚Äî skip snapshot entirely rather than saving broken data
          console.warn('[Snapshot] localStorage full even after compaction, skipping save:', e2.message);
        }
      }
    }

    function restoreFromSnapshot(snap) {
      // Re-inflate point cloud from snapshot without any API call.
      const members = snap.members;
      if (!members || members.length === 0) return 0;

      const positions   = new Float32Array(members.length * 3);
      const colors      = new Float32Array(members.length * 3);
      const sizes       = new Float32Array(members.length);
      const activities  = new Float32Array(members.length);
      const vertexIdxs  = new Float32Array(members.length);

      members.forEach((m, i) => {
        positions[i * 3]     = m.x;
        positions[i * 3 + 1] = m.y;
        positions[i * 3 + 2] = m.z;

        // Recompute colour from activity (0=blue, 0.5=teal, 1=yellow) ‚Äî fast approximation
        const t = Math.min(m.activity * 5, 1);  // activity is 0‚Äì1 from geometry
        colors[i * 3]     = t;
        colors[i * 3 + 1] = Math.min(t * 2, 1);
        colors[i * 3 + 2] = 1 - t;

        sizes[i]        = m.size || 1;
        activities[i]   = m.activity || 0;
        vertexIdxs[i]   = i;

        pointMetadata.push({
          id:             m.id,
          username:       m.username || 'Anonymous',
          profilePicture: m.proPic || null,
          position:       { x: m.x, y: m.y, z: m.z },
          risk:           '50',
          riskLevel:      'medium',
          activity:       m.activity || 0,
          sobrietyDays:   m.sobrietyDays || 0,
          cluster:        'Snapshot',
        });

        memberIndexMap.set(m.id, i);
        loadedMemberIds.add(m.id);
      });

      // Build geometry + material
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position',    new THREE.BufferAttribute(positions,  3));
      geometry.setAttribute('color',       new THREE.BufferAttribute(colors,     3));
      geometry.setAttribute('size',        new THREE.BufferAttribute(sizes,      1));
      geometry.setAttribute('activity',    new THREE.BufferAttribute(activities, 1));
      geometry.setAttribute('vertexIndex', new THREE.BufferAttribute(vertexIdxs, 1));

      const material = new THREE.ShaderMaterial({
        vertexShader:   starVertexShader,
        fragmentShader: starFragmentShader,
        uniforms: {
          time:          { value: 0 },
          selectedIndex: { value: -1.0 },
        },
        transparent: true,
        depthWrite:  false,
        blending:    THREE.NormalBlending,
      });

      if (points) {
        scene.remove(points);
        points.geometry.dispose();
        points.material.dispose();
      }
      points = new THREE.Points(geometry, material);
      scene.add(points);

      return members.length;
    }

    function updateSnapshotStatus(count, timestamp, suffix = '') {
      const el = document.getElementById('snapshot-status');
      if (!el) return;
      const age = Math.round((Date.now() - timestamp) / 1000);
      const ageStr = age < 60 ? age + 's ago'
                   : age < 3600 ? Math.round(age/60) + 'm ago'
                   : Math.round(age/3600) + 'h ago';
      el.textContent = `Snapshot: ${count.toLocaleString()} members ¬∑ saved ${ageStr} ${suffix}`;
    }

    window.clearSnapshot = () => {
      localStorage.removeItem(SNAPSHOT_KEY);
      const el = document.getElementById('snapshot-status');
      if (el) el.textContent = 'Snapshot cleared.';
    };

    // Show snapshot info on load
    (function() {
      const snap = loadSnapshot();
      if (snap) updateSnapshotStatus(snap.members.length, snap.timestamp);
    })();
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    window.startLoadRealDataJob = async () => {
      const job = createJob('Load Real Data', 'data-load');

      try {
        // 0. Try to restore from snapshot first (instant, no API calls)
        const snap = loadSnapshot();
        let skips;
        if (snap && snap.skips) {
          skips = snap.skips;
          if (pointMetadata.length === 0) {
            // First call this session ‚Äî restore the rendered universe from snapshot
            updateJob(job.id, { message: `Restoring ${snap.members.length.toLocaleString()} members from snapshot...`, progress: 5 });
            const restored = restoreFromSnapshot(snap);
            const realCount = loadedMemberIds.size;
            document.getElementById('admin-total').textContent = realCount.toLocaleString();
            document.getElementById('admin-real').textContent  = realCount.toLocaleString();
            document.getElementById('admin-synthetic').textContent = '0';
            document.getElementById('count').textContent = realCount.toLocaleString();
            updateJob(job.id, { message: `Restored ${restored.toLocaleString()} members from snapshot. Checking for new members...`, progress: 15 });
            applyUserFromUrl();
          }
        } else {
          // No snapshot ‚Äî load from localStorage skips or start fresh
          const savedState = localStorage.getItem('universeJobState');
          skips = savedState
            ? JSON.parse(savedState)
            : { userSkip: 0, postSkip: 0, commentSkip: 0, totalMembers: 0, isComplete: false };
          // If the snapshot was invalidated (version bump) but skips says complete,
          // we must reload from scratch ‚Äî otherwise the while loop never runs and
          // the universe stays empty (no stars, no images).
          if (!snap && skips.isComplete) {
            skips = { userSkip: 0, postSkip: 0, commentSkip: 0, totalMembers: 0, isComplete: false };
            localStorage.removeItem('universeJobState');
          }
        }

        // 1. Exit if job already complete and snapshot is fresh (< 1 hour old)
        if (skips.isComplete && snap && (Date.now() - snap.timestamp) < 3600000) {
          updateJob(job.id, {
            status: 'completed',
            message: 'Universe fully loaded from snapshot',
            progress: 100
          });
          return;
        }

        updateJob(job.id, {
          message: skips.totalMembers > 0
            ? `Fetching new members (have ${skips.totalMembers.toLocaleString()})...`
            : 'Starting fresh load...',
          progress: snap ? 20 : 5
        });

        // 3. Dynamic import of Back4App and codec modules
        const back4appModule = await import('./lib/back4app.js');
        const codecModule = await import('./lib/codec.js');
        const { feedFromBack4App, DEFAULT_CONFIG } = back4appModule;
        const { createState, evolve, DEFAULT_PARAMS } = codecModule;

        updateJob(job.id, { message: 'Initializing state...', progress: 10 });

        const state = createState();
        const BATCH_SIZE = 500;
        const MAX_MEMBERS = 600000; // Target all members
        const MAX_BATCHES_PER_RUN = 5; // Load 5 batches per run, then pause

        // 4. Continuous loading loop
        let batchesThisRun = 0;
        while (!skips.isComplete && skips.totalMembers < MAX_MEMBERS && batchesThisRun < MAX_BATCHES_PER_RUN) {
          const batchConfig = {
            userLimit: BATCH_SIZE,
            postLimit: 100,
            commentLimit: 200,
            soberDateChangeLimit: 0,
          };

          const membersBefore = state.members.size;

          await feedFromBack4App(DEFAULT_CONFIG, state, skips, batchConfig);

          const membersAfter = state.members.size;
          const newMembersCount = membersAfter - membersBefore;

          skips.totalMembers = membersAfter;
          skips.lastUpdate = Date.now();
          batchesThisRun++;

          // Save to localStorage after each batch
          localStorage.setItem('universeJobState', JSON.stringify(skips));

          updateJob(job.id, {
            message: `Loaded ${skips.totalMembers} members (batch ${batchesThisRun}, +${newMembersCount} new)...`,
            progress: Math.min(95, (skips.totalMembers / MAX_MEMBERS) * 100)
          });

          // Check if no new members were loaded (reached end)
          if (newMembersCount === 0) {
            skips.isComplete = true;
            localStorage.setItem('universeJobState', JSON.stringify(skips));
            break;
          }

          // Small delay to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        // 5. Compute spatial positions if we have members
        if (state.members.size > 0) {
          updateJob(job.id, { message: 'Computing spatial layout...', progress: 90 });

          if (state.members.size > 10) {
            evolve(state, DEFAULT_PARAMS);
          }

          // 6. Enrich point cloud incrementally
          updateJob(job.id, { message: 'Updating visualization...', progress: 95 });
          enrichPointCloudData(state);

          // 7. Save snapshot so next load is instant
          updateJob(job.id, { message: 'Saving snapshot...', progress: 97 });
          saveSnapshot(skips);
        }

        // 8. Update UI
        const realCount = loadedMemberIds.size;
        document.getElementById('admin-total').textContent = realCount.toLocaleString();
        document.getElementById('admin-real').textContent = realCount.toLocaleString();
        document.getElementById('admin-synthetic').textContent = '0';
        document.getElementById('count').textContent = realCount.toLocaleString();

        if (skips.isComplete) {
          updateJob(job.id, {
            status: 'completed',
            progress: 100,
            message: `Loaded all ${skips.totalMembers} members`
          });
        } else {
          updateJob(job.id, {
            status: 'completed',
            progress: Math.min(95, (skips.totalMembers / MAX_MEMBERS) * 100),
            message: `Loaded ${skips.totalMembers} members (will continue on next run)`
          });

          // Auto-continue loading after a delay
          setTimeout(() => {
            startLoadRealDataJob();
          }, 5000); // Wait 5 seconds before next batch
        }

      } catch (err) {
        console.error('Load real data error:', err);

        // Save state even on error so we can resume
        const savedState = localStorage.getItem('universeJobState');
        if (savedState) {
          const skips = JSON.parse(savedState);
          localStorage.setItem('universeJobState', JSON.stringify(skips));
        }

        updateJob(job.id, {
          status: 'error',
          progress: 0,
          message: `Error: ${err.message}`
        });
      }
    };

    // Auto-update jobs every second
    setInterval(() => {
      const runningJobs = jobs.filter(j => j.status === 'running');
      if (runningJobs.length > 0) {
        renderJobs();
      }
    }, 1000);

    init();
  </script>
</body>
</html>
